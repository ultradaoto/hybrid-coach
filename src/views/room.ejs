<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= title %></title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #f9fafb;
        flex-direction: column;
      }
      #videoContainer{ display:flex; }
      #videoContainer.reverse{ flex-direction:row-reverse; }
      video {
        width: 45%;
        max-width: 480px;
        border: 2px solid #2d3748;
        margin: 0.5rem;
      }
      #messages { height:120px; overflow:auto; width:90%; margin-top:1rem; background:#fff; padding:0.5rem; border:1px solid #ccc; }
    </style>
  </head>
  <body>
    <h2>Hybrid Coaching Call</h2>
    <div id="videoContainer">
      <video id="localVideo" autoplay playsinline muted></video>
      <video id="remoteVideo" autoplay playsinline></video>
      <div style="display:flex; width:100%; justify-content:center;">
        <span id="localLabel" style="width:45%; text-align:center;"></span>
        <span id="remoteLabel" style="width:45%; text-align:center;"></span>
      </div>
    </div>
    <div id="messages"></div>
    <div style="margin-top:0.5rem; width:90%; display:flex;">
      <input id="msgInput" style="flex:1; padding:0.5rem" placeholder="Type a message to Hybrid AI..." />
      <button id="sendBtn">Send</button>
    </div>
    <div style="margin-top:0.5rem; font-weight:bold;" id="callTimer">00:00</div>

    <script src="/socket.io/socket.io.js"></script>

    <!-- Load mediasoup-client and protoo-client as ES modules -->
    <script type="module">
      import mediasoupClientModule from 'https://esm.sh/mediasoup-client@3.11.0';
      import protooClientModule from 'https://esm.sh/protoo-client@4.0.4';
      
      window.mediasoupClient = mediasoupClientModule; // Expose the whole module
      window.protooClient = protooClientModule;
      
      console.log('mediasoup-client and protoo-client modules script has run.');
      // Consider a custom event here if waitForDependencies needs a more robust signal
    </script>

    <!-- Main application logic script -->
    <script>
      // Wait for dependencies to load (now set by the module script)
      function waitForDependencies(callback) {
        const messagesDiv = document.getElementById('messages'); // Get messages div for logging
        function persistentLog(msg) { // Helper to log to console and page
            console.log(msg);
            if(messagesDiv) messagesDiv.innerHTML += msg + '<br>';
        }

        persistentLog('Initializing: Waiting for client libraries...');
        const checkInterval = setInterval(() => {
          const msClientReady = !!window.mediasoupClient;
          const ptClientReady = !!window.protooClient;

          if (msClientReady && ptClientReady) {
            clearInterval(checkInterval);
            persistentLog('‚úÖ All client libraries (mediasoupClient, protooClient) are loaded.');
            callback();
          } else {
            persistentLog('‚è≥ Waiting... mediasoupClient: ' + (msClientReady ? 'OK' : 'MISSING') + ', protooClient: ' + (ptClientReady ? 'OK' : 'MISSING'));
          }
        }, 200); // Check every 200ms for visibility
      }

      waitForDependencies(() => {
        // Main app logic will now use window.mediasoupClient.Device etc.
        // ... (rest of the main script) ...
        const roomId = "<%= roomId %>";
        const userRole = "<%= user.role %>";
        const userName = "<%= user.displayName || user.email %>";
        const jwtToken = "<%= jwt %>";
        const sessionId = "<%= sessionId %>";
        localStorage.setItem('jwt', jwtToken);
        const socket = io(); // This is for general app signaling (chat, timer, etc.)
        const messages = document.getElementById('messages');

        const peerId = `pid_${Math.random().toString(36).substr(2, 9)}`;
        let protooPeer;

        function log(msg){ messages.innerHTML += msg + '<br>'; }

        socket.emit('join-room', { roomId, name: userName });

        let localStream;
        let sendTransport, recvTransport, device;
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');

        document.getElementById('localLabel').innerText = userName + ' (You)';
        if(userRole === 'coach'){
          document.getElementById('videoContainer').classList.add('reverse');
        }

        const protooWebSocketUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}/protoo?roomId=${roomId}&peerId=${peerId}`;
        const transport = new window.protooClient.WebSocketTransport(protooWebSocketUrl);
        protooPeer = new window.protooClient.Peer(transport);

        protooPeer.on('open', () => {
          console.log('Protoo connection open. Calling joinSFU(). PeerID:', peerId, 'RoomID:', roomId);
          log('‚úÖ Protoo connection established.');
          joinSFU(); 
        });

        protooPeer.on('request', (request, accept, reject) => {
          console.log('Received Protoo request from server (unexpected on client):', request);
          reject(501, 'Client does not handle requests'); 
        });

        // Duplicated protooPeer.on('notification', ...) was here, ensure only one remains after merge
        // The one inside joinSFU for newProducer is more specific and should be kept if different.
        // This one is a general handler if needed.
        protooPeer.on('notification', (notification) => {
            console.log('Received global Protoo notification from server:', notification);
             if (notification.method === 'newProducer' && !device.loaded) {
                 // This might be an issue if newProducer comes before device is loaded.
                 // The handler inside joinSFU is better placed.
                 console.warn('Global newProducer notification received, but joinSFU handles this.');
             }
        });


        protooPeer.on('failed', (currentAttempt, maxAttempts) => {
          console.error(`Protoo connection attempt ${currentAttempt} of ${maxAttempts} failed. URL: ${protooWebSocketUrl}`);
          log(`üî¥ Protoo connection failed (attempt ${currentAttempt}/${maxAttempts}). Will not auto-retry.`);
        });

        protooPeer.on('disconnected', () => {
          console.error('Protoo disconnected. URL:', protooWebSocketUrl);
          log('üî¥ Protoo disconnected.');
        });

        protooPeer.on('close', () => {
          console.log('Protoo connection closed. URL:', protooWebSocketUrl);
          log('‚ÑπÔ∏è Protoo connection closed.');
        });

        function protooRequest(method, data = {}) {
          if (!protooPeer || !protooPeer.connected) {
            const errorMsg = `Protoo peer not connected. Cannot send request: ${method}`;
            console.error(errorMsg, 'Peer state:', protooPeer ? protooPeer.state : 'undefined');
            log(`üî¥ ${errorMsg}`);
            return Promise.reject(new Error(errorMsg));
          }
          return protooPeer.request(method, data);
        }

        async function makeTransport(direction) {
          console.log(`makeTransport called for ${direction}, needs Protoo implementation`);
          const { id, iceParameters, iceCandidates, dtlsParameters, sctpParameters } =
            await protooRequest('createWebRtcTransport', { producing: direction === 'send', consuming: direction === 'recv' });

          const transport = direction === 'send'
            ? device.createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters })
            : device.createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters });

          transport.on('connect', async ({ dtlsParameters: connectDtlsParameters }, callback, errback) => {
            try {
              await protooRequest('connectWebRtcTransport', { transportId: transport.id, dtlsParameters: connectDtlsParameters });
              callback();
            } catch (error) {
              errback(error);
            }
          });

          if (direction === 'send') {
            transport.on('produce', async ({ kind, rtpParameters, appData }, callback, errback) => {
              try {
                const { id: producerId } = await protooRequest('produce', { transportId: transport.id, kind, rtpParameters, appData });
                callback({ id: producerId });
              } catch (error) {
                errback(error);
              }
            });
          }
          return transport;
        }

        async function joinSFU(){
          log('üìπ Attempting to join SFU...'); 
          console.log('üìπ requesting camera');
          try {
            localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
            localVideo.srcObject = localStream;
            log('üé• Got local stream.');
            console.log('üé• got local stream, connecting to SFU via Protoo');
            
            // Ensure mediasoupClient is available
            if (!window.mediasoupClient || !window.mediasoupClient.Device) { // Check for Device property too
                const errMsg = 'mediasoupClient or mediasoupClient.Device is not available on window.';
                console.error(errMsg, window.mediasoupClient);
                log(`‚ùå ERROR: ${errMsg}`);
                return;
            }
            device = new window.mediasoupClient.Device(); 
            
            log('üöÄ Requesting Router RTP Capabilities...');
            const routerRtpCapabilities = await protooRequest('getRouterRtpCapabilities');
            console.log('üîß Received Router RTP Capabilities:', routerRtpCapabilities);
            log('üëç Got Router RTP Capabilities.');
            
            await device.load({ routerRtpCapabilities });
            console.log('üîß Device loaded with router capabilities');
            log('üëç Device loaded.');

            log('üöö Creating send transport...');
            sendTransport = await makeTransport('send');
            console.log('üöö send transport ready', sendTransport.id);
            log(`üëç Send transport created: ${sendTransport.id}`);
            const camTrack = localStream.getVideoTracks()[0];
            await sendTransport.produce({ track: camTrack }); 
            console.log('üì° produced local video');
            log('üì° Video produced.');

            log('üì• Creating recv transport...');
            recvTransport = await makeTransport('recv');
            console.log('üì• recv transport ready', recvTransport.id);
            log(`üëç Recv transport created: ${recvTransport.id}`);

            // This specific notification handler for newProducer should be inside joinSFU
            // if it relies on `device` or `recvTransport` which are scoped/initialized here.
            // Remove or ensure the global one doesn't conflict.
            // For now, let's assume this is the primary one.
            protooPeer.off('notification'); // Remove any generic/previous ones
            protooPeer.on('notification', async (notification) => {
              console.log('Received Protoo notification (specific to joinSFU):', notification);
              if (notification.method === 'newProducer') {
                const { producerId, kind, appData } = notification.data; 
                console.log('üÜï new producer notification', producerId, kind, appData);
                log(`üÜï Seeing new producer: ${producerId} (${kind})`);
                try {
                  if (!device.loaded) {
                    console.warn('Device not loaded yet, cannot consume. ProducerId:', producerId);
                    log('‚ö†Ô∏è Device not loaded, cannot consume yet.');
                    return;
                  }
                  if (!recvTransport) {
                    console.warn('Receive transport not ready, cannot consume. ProducerId:', producerId);
                    log('‚ö†Ô∏è Receive transport not ready, cannot consume yet.');
                    return;
                  }

                  const { id: consumerId, producerId: remoteProducerId, kind: remoteKind, rtpParameters } = await protooRequest('consume', {
                    rtpCapabilities: device.rtpCapabilities,
                    producerId,
                  });
                  const consumer = await recvTransport.consume({
                    id: consumerId,
                    producerId: remoteProducerId, 
                    kind: remoteKind, 
                    rtpParameters,
                  });
                  const ms = new MediaStream([consumer.track]);
                  remoteVideo.srcObject = ms;
                  log(`üéß Consuming remote stream: ${producerId}`);
                  // await protooRequest('resumeConsumer', { consumerId }); 
                } catch (err) {
                  console.error('Error consuming new producer:', err);
                  log(`‚ùå ERROR consuming producer ${producerId}: ${err.message}`);
                }
              }
            });
            log('üéß Listening for new producers...');
            aiGreeting(); // Call AI greeting once SFU setup is initiated

          } catch (err) {
            console.error('Error in joinSFU:', err);
            log(`‚ùå ERROR in joinSFU: ${err.message}`);
          }
        }
        
        // AI greeting after media & SFU ready (or at least initiated)
        async function aiGreeting(){
          const greetingPrompt = `Say: Hello ${userName}. Welcome to the session! How are things going with Ultra so far?`;
          const res = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message: greetingPrompt, userId:'<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: '+data.reply);
          // await logMessage('ai', data.reply); // logMessage might not be defined here.
          // playTTS(data.reply); // playTTS might not be defined here.
        }

        // Chat with AI (ensure logMessage and playTTS are available or remove)
        const inputEl = document.getElementById('msgInput');
        document.getElementById('sendBtn').onclick = async () => {
          const text = inputEl.value.trim();
          if(!text) return;
          log('You: ' + text);
          inputEl.value='';
          // await logMessage('client', text);
          const res  = await fetch('/api/chat', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ message: text, userId: '<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: ' + data.reply);
          // await logMessage('ai', data.reply);
          // playTTS(data.reply);
        };

        // Call timer & 15-minute callback
        const timerEl = document.getElementById('callTimer');
        let originTs = null;
        socket.on('room-start', ts => { originTs = ts; });

        let fifteenFired = false;
        setInterval(async () => {
          if(originTs === null) return;
          const elapsed = Math.floor((Date.now() - originTs)/1000);
          const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
          const ss = String(elapsed%60).padStart(2,'0');
          timerEl.textContent = `${mm}:${ss}`;

          if (!fifteenFired && elapsed >= 900){ // 15 minutes = 900 seconds
            fifteenFired = true;
            const note = 'System: The coach has another call in 5 minutes and will step away soon. Please provide any final recommendations for the next week of Ultra use.';
            // await logMessage('system', note);
            const res = await fetch('/api/chat', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ message: note, userId:'<%= user.id %>', sessionId }) });
            const data = await res.json();
            log('AI: '+data.reply);
            // await logMessage('ai', data.reply);
            // playTTS(data.reply);
          }
        },1000);
        
      }); // End of waitForDependencies callback
    </script>
  </body>
</html> 