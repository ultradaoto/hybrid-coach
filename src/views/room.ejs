<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= title %></title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #f9fafb;
        flex-direction: column;
      }
      #videoContainer{ display:flex; }
      #videoContainer.reverse{ flex-direction:row-reverse; }
      video {
        width: 45%;
        max-width: 480px;
        border: 2px solid #2d3748;
        margin: 0.5rem;
      }
      #messages { height:120px; overflow:auto; width:90%; margin-top:1rem; background:#fff; padding:0.5rem; border:1px solid #ccc; }
    </style>
  </head>
  <body>
    <h2>Hybrid Coaching Call</h2>
    <div id="videoContainer">
      <video id="localVideo" autoplay playsinline muted></video>
      <video id="remoteVideo" autoplay playsinline></video>
      <div style="display:flex; width:100%; justify-content:center;">
        <span id="localLabel" style="width:45%; text-align:center;"></span>
        <span id="remoteLabel" style="width:45%; text-align:center;"></span>
      </div>
    </div>
    <div id="messages"></div>
    <div style="margin-top:0.5rem; width:90%; display:flex;">
      <input id="msgInput" style="flex:1; padding:0.5rem" placeholder="Type a message to Hybrid AI..." />
      <button id="sendBtn">Send</button>
    </div>
    <div style="margin-top:0.5rem; font-weight:bold;" id="callTimer">00:00</div>
    <div style="margin-top:1rem;">
      <a href="/room/<%= roomId %>/fallback" class="fallback-link">Switch to Simple WebSocket Mode</a>
    </div>

    <script src="/socket.io/socket.io.js"></script>

    <!-- Load mediasoup-client and protoo-client as ES modules -->
    <script type="module">
      import mediasoupClientModule from 'https://esm.sh/mediasoup-client@3.11.0';
      import protooClientModule from 'https://esm.sh/protoo-client@4.0.4';
      
      window.mediasoupClient = mediasoupClientModule; // Expose the whole module
      window.protooClient = protooClientModule;
      
      console.log('mediasoup-client and protoo-client modules script has run.');
      // Consider a custom event here if waitForDependencies needs a more robust signal
    </script>

    <!-- Main application logic script -->
    <script>
      // Wait for dependencies to load (now set by the module script)
      function waitForDependencies(callback) {
        const messagesDiv = document.getElementById('messages'); // Get messages div for logging
        function persistentLog(msg) { // Helper to log to console and page
            console.log(msg);
            if(messagesDiv) messagesDiv.innerHTML += msg + '<br>';
        }

        persistentLog('Initializing: Waiting for client libraries...');
        const checkInterval = setInterval(() => {
          const msClientReady = !!window.mediasoupClient;
          const ptClientReady = !!window.protooClient;

          if (msClientReady && ptClientReady) {
            clearInterval(checkInterval);
            persistentLog('‚úÖ All client libraries (mediasoupClient, protooClient) are loaded.');
            callback();
          } else {
            persistentLog('‚è≥ Waiting... mediasoupClient: ' + (msClientReady ? 'OK' : 'MISSING') + ', protooClient: ' + (ptClientReady ? 'OK' : 'MISSING'));
          }
        }, 200); // Check every 200ms for visibility
      }

      waitForDependencies(() => {
        // Main app logic will now use window.mediasoupClient.Device etc.
        // ... (rest of the main script) ...
        const roomId = "<%= roomId %>";
        const userRole = "<%= user.role %>";
        const userName = "<%= user.displayName || user.email %>";
        const jwtToken = "<%= jwt %>";
        const sessionId = "<%= sessionId %>";
        localStorage.setItem('jwt', jwtToken);
        const socket = io(window.location.origin, {
          path: '/socket.io/',
          transports: ['polling', 'websocket'], // Allow both types but try websocket first
          reconnectionAttempts: 10,
          reconnectionDelay: 1000, // Increase timeout
          timeout: 20000, // Increase timeout
          pingInterval: 25000, // Send a ping every 25 seconds
          pingTimeout: 60000, // Wait 60 seconds for a pong response
          auth: {
            token: jwtToken // Include auth token for socket connections
          }
        });
        const messages = document.getElementById('messages');

        let localStream;
        let sendTransport, recvTransport, device;
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        
        const wantsVideo = !window.location.search.includes('novideo'); // Only affects sending
        const canReceiveVideo = true; // Always enable video receiving
        const stunServers = [ // Public STUN servers with fallbacks
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
          // Limiting to just a couple of reliable STUN servers
        ];
        debugClient(`Client wantsVideo: ${wantsVideo}`);

        let pendingProducersToConsume = [];
        
        // Add a flag to track if joinSFU is already running
        let joinSfuInProgress = false;
        
        // Generate a stable peer ID for this user/device that persists across reconnections
        function getStablePeerId() {
          // Look for existing peer ID in localStorage
          let storedPeerId = localStorage.getItem('mediasoup_peer_id');
          
          // If no stored ID or it's from a different room, generate a new one
          if (!storedPeerId || !storedPeerId.startsWith(`${roomId}_`)) {
            storedPeerId = `${roomId}_pid_${Math.random().toString(36).substr(2, 9)}`;
            localStorage.setItem('mediasoup_peer_id', storedPeerId);
          }
          
          // Extract just the peer ID part
          return storedPeerId.split('_').slice(1).join('_');
        }
        
        // Generate stable peer ID
        const peerId = getStablePeerId();
        debugClient(`Using peer ID: ${peerId}`);
        
        let protooPeer;

        function log(msg){ messages.innerHTML += msg + '<br>'; }
        function debugClient(message) { console.log('[CLIENT DEBUG]', message); }

        socket.emit('join-room', { roomId, name: userName });

        document.getElementById('localLabel').innerText = userName + ' (You)';
        if(userRole === 'coach'){
          document.getElementById('videoContainer').classList.add('reverse');
        }

        const protooWebSocketUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}/protoo?roomId=${roomId}&peerId=${peerId}`;
        const transport = new window.protooClient.WebSocketTransport(protooWebSocketUrl);
        protooPeer = new window.protooClient.Peer(transport);
        
        // CRITICAL FIX: Intercept WebSocket messages to handle response format issues
        if (transport._ws) {
          const originalOnMessage = transport._ws.onmessage;
          transport._ws.onmessage = function(event) {
            try {
              // Check if this looks like a server response
              const response = JSON.parse(event.data);
              if (response && typeof response === 'object' && response.id) {
                debugClient(`[WebSocketFix] Intercepted WebSocket message for ID ${response.id}:`, event.data.substring(0, 100) + '...');
                
                // If it's an empty response where it shouldn't be, try to inspect and fix
                if (response.ok === true && (!response.response || Object.keys(response.response).length === 0)) {
                  // This might be a protocol mismatch - log it
                  console.warn(`[WebSocketFix] Detected potentially problematic empty response for ID ${response.id}`);
                  
                  // If this is for createWebRtcTransport, check if we can extract data from event.data
                  try {
                    const rawData = JSON.parse(event.data);
                    console.log(`[WebSocketFix] Raw message:`, rawData);
                    
                    // If we have a response field with useful data inside the event, use it
                    if (rawData.response && typeof rawData.response === 'object' && rawData.response.id) {
                      debugClient(`[WebSocketFix] Found useful response data in message`);
                      // Create a new event with the fixed data
                      const newEvent = new MessageEvent('message', {
                        data: JSON.stringify(rawData.response)
                      });
                      // Call the original handler with our fixed event
                      originalOnMessage.call(this, newEvent);
                      return; // Skip original handler for this event
                    }
                  } catch (e) {
                    console.error(`[WebSocketFix] Error parsing/fixing response:`, e);
                  }
                }
              }
            } catch (e) {
              // Not JSON or other error, just let original handler deal with it
            }
            
            // Call original handler for unmodified events
            originalOnMessage.call(this, event);
          };
          debugClient(`[WebSocketFix] WebSocket message interceptor installed`);
        } else {
          debugClient(`[WebSocketFix] Cannot access WebSocket to install interceptor`);
        }
        
        // CRITICAL FIX: Patch protoo Peer.request method to fix protocol issues
        if (protooPeer && protooPeer.request) {
          // Store original method
          const originalRequest = protooPeer.request;
          
          // Replace with our fixed version
          protooPeer.request = function(method, data) {
            debugClient(`[ProtooFix] Intercepted request for method: ${method}`);
            
            // Use the original request method
            return originalRequest.call(this, method, data)
              .then(response => {
                // Check if response needs fixing
                debugClient(`[ProtooFix] Raw response for ${method}:`, response);
                
                // For createWebRtcTransport, ensure we have a properly formed response
                if (method === 'createWebRtcTransport') {
                  if (!response || typeof response !== 'object' || !response.id) {
                    console.warn(`[ProtooFix] Invalid response for ${method}:`, response);
                    
                    // If response.response exists with an ID, use that instead
                    if (response && typeof response === 'object' && 
                        response.response && typeof response.response === 'object' && 
                        response.response.id) {
                      console.log(`[ProtooFix] Using nested response:`, response.response);
                      return response.response;
                    }
                  }
                }
                
                return response;
              });
          };
          
          debugClient(`[ProtooFix] Successfully patched Peer.request method`);
        } else {
          console.error(`[ProtooFix] Failed to patch Peer.request - method not found`);
        }
        
        // Keep track of reconnection attempts
        let protooReconnectAttempts = 0;
        const MAX_PROTOO_RECONNECT_ATTEMPTS = 10;
        let protooReconnectTimeout = null;
        let initialConnectionEstablished = false;
        
        function setupProtooConnectionHandlers() {
          protooPeer.on('open', () => {
            console.log('Protoo connection open. Will call joinSFU() when fully connected. PeerID:', peerId, 'RoomID:', roomId);
            log('‚úÖ Protoo connection established.');
            protooReconnectAttempts = 0; // Reset counter on successful connection
            if (protooReconnectTimeout) {
              clearTimeout(protooReconnectTimeout);
              protooReconnectTimeout = null;
            }
            
            // Wait a moment to ensure full connection before starting
            setTimeout(() => {
              initialConnectionEstablished = true;
              // Restart keepalive when connection is established
              if (typeof startKeepalive === 'function') {
                debugClient('Restarting keepalive after reconnection');
                startKeepalive();
              }
              
              console.log('Protoo connection fully ready. Starting joinSFU().');
              joinSFU();
            }, 500);
          });

          protooPeer.on('request', (request, accept, reject) => {
            console.log('Received Protoo request from server (unexpected on client):', request);
            
            // Handle ping requests from server
            if (request.method === 'ping') {
              debugClient(`Received ping request from server, responding`);
              accept({ timestamp: Date.now() });
              return;
            }
            
            // Reject all other requests
            reject(501, 'Client does not handle requests'); 
          });

          // Generic notification handler - primarily for newProducers
          protooPeer.on('notification', async (notification) => {
            debugClient(`Received Protoo notification: ${notification.method}`);
            if (notification.method === 'newProducer') {
              const producerInfo = notification.data;
              if (device && device.loaded) {
                debugClient('Device is loaded, consuming producer immediately:', producerInfo.producerId);
                await consumeProducer(producerInfo);
              } else {
                debugClient('Device not loaded yet, queueing producer:', producerInfo.producerId);
                pendingProducersToConsume.push(producerInfo);
                log('‚ö†Ô∏è Device not loaded, producer queued: ' + producerInfo.producerId);
              }
            }
          });

          protooPeer.on('failed', (currentAttempt, maxAttempts) => {
            console.error(`Protoo connection attempt ${currentAttempt} of ${maxAttempts} failed. URL: ${protooWebSocketUrl}`);
            log(`üî¥ Protoo connection failed (attempt ${currentAttempt}/${maxAttempts}). Will not auto-retry.`);
            
            // Only try reconnecting if we haven't exceeded our custom attempt limit
            if (protooReconnectAttempts < MAX_PROTOO_RECONNECT_ATTEMPTS) {
              protooReconnectAttempts++;
              const delay = Math.min(1000 * (protooReconnectAttempts * 2), 30000); // Exponential backoff with 30s max
              
              log(`üîÑ Attempting protoo reconnect in ${delay/1000} seconds... (${protooReconnectAttempts}/${MAX_PROTOO_RECONNECT_ATTEMPTS})`);
              
              if (protooReconnectTimeout) clearTimeout(protooReconnectTimeout);
              protooReconnectTimeout = setTimeout(() => {
                try {
                  // Close existing peer and transport fully before creating new ones
                  if (protooPeer) {
                    try {
                      protooPeer.close();
                    } catch (e) {
                      console.warn('Error closing protoo peer:', e);
                    }
                  }
                  
                  if (transport) {
                    try {
                      transport.close();
                    } catch (e) {
                      console.warn('Error closing transport:', e);
                    }
                  }
                  
                  // Clean up any existing transports
                  if (sendTransport) {
                    try {
                      sendTransport.close();
                    } catch (e) {}
                    sendTransport = null;
                  }
                  
                  if (recvTransport) {
                    try {
                      recvTransport.close();
                    } catch (e) {}
                    recvTransport = null;
                  }
                  
                  // Clear any existing device
                  device = null;
                  
                  // Allow a moment for resources to be cleaned up
                  setTimeout(() => {
                    log('üîÑ Creating fresh connection...');
                    // Create new transport and peer
                    const newTransport = new window.protooClient.WebSocketTransport(protooWebSocketUrl);
                    protooPeer = new window.protooClient.Peer(newTransport);
                    setupProtooConnectionHandlers(); // Setup handlers on new peer
                  }, 500);
                } catch (err) {
                  console.error('Error creating new protoo connection:', err);
                  log(`‚ùå Failed to create new protoo connection: ${err.message}`);
                }
              }, delay);
            } else {
              log(`‚ùå Maximum protoo reconnection attempts (${MAX_PROTOO_RECONNECT_ATTEMPTS}) reached. Please refresh the page.`);
            }
          });

          protooPeer.on('disconnected', () => {
            console.error('Protoo disconnected. URL:', protooWebSocketUrl);
            log('üî¥ Protoo disconnected.');
            
            // Handle disconnection similarly to connection failure
            if (protooReconnectAttempts < MAX_PROTOO_RECONNECT_ATTEMPTS) {
              protooReconnectAttempts++;
              const delay = Math.min(1000 * (protooReconnectAttempts * 2), 15000); // Shorter delay for disconnect
              
              log(`üîÑ Attempting protoo reconnect after disconnect in ${delay/1000} seconds... (${protooReconnectAttempts}/${MAX_PROTOO_RECONNECT_ATTEMPTS})`);
              
              if (protooReconnectTimeout) clearTimeout(protooReconnectTimeout);
              protooReconnectTimeout = setTimeout(() => {
                try {
                  // Close existing peer and transport fully before creating new ones
                  if (protooPeer) {
                    try {
                      protooPeer.close();
                    } catch (e) {
                      console.warn('Error closing protoo peer:', e);
                    }
                  }
                  
                  if (transport) {
                    try {
                      transport.close();
                    } catch (e) {
                      console.warn('Error closing transport:', e);
                    }
                  }
                  
                  // Clean up any existing transports
                  if (sendTransport) {
                    try {
                      sendTransport.close();
                    } catch (e) {}
                    sendTransport = null;
                  }
                  
                  if (recvTransport) {
                    try {
                      recvTransport.close();
                    } catch (e) {}
                    recvTransport = null;
                  }
                  
                  // Clear any existing device
                  device = null;
                  
                  // Allow a moment for resources to be cleaned up
                  setTimeout(() => {
                    log('üîÑ Creating fresh connection...');
                    // Create new transport and peer
                    const newTransport = new window.protooClient.WebSocketTransport(protooWebSocketUrl);
                    protooPeer = new window.protooClient.Peer(newTransport);
                    setupProtooConnectionHandlers(); // Setup handlers on new peer
                  }, 500);
                } catch (err) {
                  console.error('Error creating new protoo connection:', err);
                  log(`‚ùå Failed to create new protoo connection: ${err.message}`);
                }
              }, delay);
            }
          });

          protooPeer.on('close', () => {
            console.log('Protoo connection closed. URL:', protooWebSocketUrl);
            log('‚ÑπÔ∏è Protoo connection closed.');
            
            // Clean up intervals to prevent leaks
            if (keepaliveInterval) {
              clearInterval(keepaliveInterval);
              keepaliveInterval = null;
            }
            
            if (connectionMonitorInterval) {
              clearInterval(connectionMonitorInterval);
              connectionMonitorInterval = null;
            }
          });
        }
        
        // Setup initial connection handlers
        setupProtooConnectionHandlers();

        function protooRequest(method, data = {}) {
          if (!protooPeer) {
            const errorMsg = `Protoo peer not created yet. Cannot send request: ${method}`;
            console.error(errorMsg);
            log(`üî¥ ${errorMsg}`);
            return Promise.reject(new Error(errorMsg));
          }
          
          // Make sure the peer is connected before sending requests
          if (!protooPeer.connected) {
            const errorMsg = `Protoo peer not connected. Cannot send request: ${method}`;
            console.error(errorMsg, 'Peer state:', protooPeer ? protooPeer.connected : 'undefined');
            log(`üî¥ ${errorMsg}`);
            
            // If this is the first connection attempt, wait a bit and retry
            if (method === 'getRouterRtpCapabilities' && protooReconnectAttempts === 0) {
              log(`‚è≥ Waiting for connection to establish before sending ${method}...`);
              return new Promise((resolve, reject) => {
                // Try again in 1 second
                setTimeout(() => {
                  if (protooPeer && protooPeer.connected) {
                    log(`‚úÖ Connection established, retrying ${method} request...`);
                    protooPeer.request(method, data)
                      .then(resolve)
                      .catch(reject);
                  } else {
                    reject(new Error(`Connection timeout for ${method} request`));
                  }
                }, 1000);
              });
            }
            
            return Promise.reject(new Error(errorMsg));
          }
          
          // Enhanced request handling with retries for critical operations
          if (method === 'createWebRtcTransport' || method === 'connectWebRtcTransport') {
            log(`üîÑ Sending ${method} with extended timeout...`);
            
            return new Promise((resolve, reject) => {
              // First attempt with longer timeout
              let resolved = false;
              let rejected = false;
              
              // Create a custom timeout - longer than default for transport operations
              const timeoutMs = method === 'createWebRtcTransport' ? 15000 : 10000;
              
              // Keep track of attempts
              let attemptNum = 1;
              const maxAttempts = 3;
              
              function attemptRequest() {
                if (resolved || rejected) return;
                
                log(`üîÑ Attempt #${attemptNum} for ${method}...`);
                
                // Create timeout handler
                const timeoutId = setTimeout(() => {
                  if (!resolved && !rejected) {
                    console.warn(`[protooRequest] Timeout for ${method} (attempt ${attemptNum}/${maxAttempts})`);
                    
                    // If we haven't reached max attempts, try again
                    if (attemptNum < maxAttempts) {
                      attemptNum++;
                      log(`‚è≥ Request timeout, retrying ${method}...`);
                      attemptRequest(); // Recursive retry
                    } else {
                      rejected = true;
                      reject(new Error(`request timeout after ${maxAttempts} attempts`));
                    }
                  }
                }, timeoutMs);
                
                // Send the actual request
                protooPeer.request(method, data)
                  .then((result) => {
                    if (!rejected) {
                      clearTimeout(timeoutId);
                      resolved = true;
                      
                      // CRITICAL FIX: Debug the response structure
                      console.log(`[protooRequest] ${method} response received:`, result);
                      
                      // For createWebRtcTransport, verify we have an id
                      if (method === 'createWebRtcTransport') {
                        if (!result || typeof result !== 'object' || !result.id) {
                          console.error(`[protooRequest] Invalid ${method} response:`, result);
                          log(`‚ö†Ô∏è Invalid response format, fixing...`);
                          
                          // Attempt to fix missing ID issue
                          if (result && typeof result === 'object' && result.response && result.response.id) {
                            // The server sent { response: { id: ... } } but we need { id: ... }
                            result = result.response;
                            console.log(`[protooRequest] Fixed response format:`, result);
                          }
                        }
                      }
                      
                      log(`‚úÖ ${method} succeeded on attempt #${attemptNum}`);
                      resolve(result);
                    }
                  })
                  .catch((error) => {
                    if (!rejected) {
                      clearTimeout(timeoutId);
                      
                      // If it's a timeout error and we haven't reached max attempts, retry
                      if (error.message.includes('timeout') && attemptNum < maxAttempts) {
                        attemptNum++;
                        log(`‚è≥ Request error: ${error.message}, retrying ${method}...`);
                        setTimeout(() => attemptRequest(), 1000); // Wait a second before retry
                      } else {
                        rejected = true;
                        reject(error);
                      }
                    }
                  });
              }
              
              // Start the first attempt
              attemptRequest();
            });
          }
          
          // For other requests, use standard behavior
          return protooPeer.request(method, data);
        }

        function startWebRTCStats() {
          if (!recvTransport || !sendTransport) {
            debugClient('[startWebRTCStats] Transports not ready, will retry in 5s');
            setTimeout(startWebRTCStats, 5000);
            return;
          }

          // Keep track of connection state for monitoring
          let lastConnectedTime = null;
          let connectionMonitorInterval = null;
          let reconnectAttempts = 0;
          const MAX_RECONNECT_ATTEMPTS = 5;
          
          // Setup periodic ping to keep connection alive
          let keepaliveInterval = null;
          
          function startKeepalive() {
            // Clear any existing interval
            if (keepaliveInterval) {
              clearInterval(keepaliveInterval);
            }
            
            // Send a ping every 20 seconds to keep the connection alive
            keepaliveInterval = setInterval(() => {
              if (!protooPeer || !protooPeer.connected) {
                debugClient('[keepalive] Protoo peer not connected, skipping ping');
                return;
              }
              
              try {
                debugClient('[keepalive] Sending ping to server');
                protooRequest('ping', { clientTime: Date.now() })
                  .then(response => {
                    debugClient(`[keepalive] Ping successful, server time: ${response.timestamp}`);
                    // Update last activity time
                    lastConnectedTime = Date.now();
                  })
                  .catch(err => {
                    debugClient(`[keepalive] Ping failed: ${err.message}`);
                    // Could trigger reconnection here if needed
                  });
              } catch (e) {
                debugClient(`[keepalive] Error sending ping: ${e.message}`);
              }
            }, 20000); // Every 20 seconds
          }
          
          // Start the keepalive immediately
          startKeepalive();
          
          // Function to check and maintain connection
          function monitorConnection() {
            try {
              if (!recvTransport || !sendTransport) return;
              
              const recvState = recvTransport.connectionState;
              const sendState = sendTransport.connectionState;
              
              // Special handling for Edge browser's receive transport stuck in "new" state
              const isEdge = /Edge/.test(navigator.userAgent) || /Edg/.test(navigator.userAgent);
              if (isEdge && recvState === 'new') {
                // Check how long the transport has been in "new" state
                const transportCreatedAt = recvTransport._createdAt || 0;
                const stuckTime = Math.floor((Date.now() - transportCreatedAt) / 1000);
                
                if (stuckTime > 15) {  // If stuck in "new" for more than 15 seconds
                  debugClient('[monitorConnection] Edge browser transport stuck in "new" state for too long');
                  log(`‚ö†Ô∏è Edge browser transport stuck in "new" state for ${stuckTime}s. Forcing TCP TURN reconnection...`);
                  
                  // Close existing transport
                  try {
                    recvTransport.close();
                  } catch (e) {
                    debugClient(`[monitorConnection] Error closing stuck receive transport: ${e.message}`);
                  }
                  
                  recvTransport = null;
                  
                  // Force a TCP TURN transport creation
                  setTimeout(async () => {
                    try {
                      const tcpTurnOptions = {
                        iceTransportPolicy: 'relay',  // Force TURN relay
                        additionalIceServers: [
                          // TCP TURN servers are more reliable through firewalls
                          {
                            urls: 'turn:global.turn.twilio.com:443?transport=tcp',
                            username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                            credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                          },
                          {
                            urls: 'turns:global.turn.twilio.com:443?transport=tcp',
                            username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                            credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                          }
                        ],
                        iceTcpPolicy: 'prefer' // Prefer TCP for better firewall traversal
                      };
                      
                      log('üì• Creating new TCP TURN receive transport...');
                      recvTransport = await makeTransport('recv', tcpTurnOptions);
                      
                      // Update stored ID
                      storeTransportIds(
                        window._transportIds && window._transportIds.send ? window._transportIds.send : null,
                        recvTransport.id
                      );
                      
                      log(`‚úÖ Created new TCP TURN receive transport: ${recvTransport.id}`);
                      
                      // Process any pending consumers
                      setTimeout(() => {
                        processPendingConsumers();
                      }, 500);
                    } catch (e) {
                      debugClient(`[monitorConnection] Error creating forced TURN transport: ${e.message}`);
                      log(`‚ùå Error creating forced TURN transport: ${e.message}`);
                    }
                  }, 1000);
                  
                  return; // Skip the rest of the monitoring for this cycle
                }
              }
              
              if (recvState === 'connected' || sendState === 'connected') {
                lastConnectedTime = Date.now();
                reconnectAttempts = 0; // Reset counter on successful connection
              } else if (lastConnectedTime) {
                // Calculate how long we've been disconnected
                const disconnectedTime = Math.floor((Date.now() - lastConnectedTime) / 1000);
                if (disconnectedTime > 15 && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                  // If disconnected for more than 15 seconds, try to reconnect
                  log(`üì° Connection lost for ${disconnectedTime} seconds. Attempting reconnection (${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})...`);
                  
                  // Send a ping/pong to check if signaling is still active
                  protooRequest('ping')
                    .then(() => {
                      debugClient('[monitorConnection] Signaling is responsive, attempting to refresh media connection');
                      
                      // Refresh receive transport
                      if (recvTransport && recvTransport.connectionState !== 'connected') {
                        log('üîÑ Reconnecting receive transport...');
                        refreshTransport('recv');
                      }
                      
                      // Refresh send transport
                      if (sendTransport && sendTransport.connectionState !== 'connected') {
                        log('üîÑ Reconnecting send transport...');
                        refreshTransport('send');
                      }
                    })
                    .catch(e => {
                      debugClient('[monitorConnection] Signaling channel unresponsive:', e);
                      log('‚ö†Ô∏è Signaling channel lost. Attempting full reconnection...');
                      
                      // More serious reconnection needed - recreate everything
                      cleanupTransports();
                      joinSFU();
                    });
                  
                  reconnectAttempts++;
                  lastConnectedTime = Date.now(); // Reset timer to avoid multiple attempts too quickly
                } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                  log('‚ö†Ô∏è Maximum reconnection attempts reached. Please refresh the page.');
                  clearInterval(connectionMonitorInterval);
                }
              }
            } catch (e) {
              debugClient('[monitorConnection] Error monitoring connection:', e);
            }
          }
          
          // Function to clean up transports
          function cleanupTransports() {
            if (recvTransport) {
              try {
                recvTransport.close();
              } catch (e) {
                debugClient('Error closing receive transport:', e);
              }
              recvTransport = null;
            }
            
            if (sendTransport) {
              try {
                sendTransport.close();
              } catch (e) {
                debugClient('Error closing send transport:', e);
              }
              sendTransport = null;
            }
          }

          // Give more time for connection to establish - wait 20 seconds before first check
          setTimeout(() => {
            // Check stats every 5 seconds
            const statsInterval = setInterval(async () => {
              try {
                if (!recvTransport || !sendTransport) {
                  debugClient('[webrtcStats] Transports closed, stopping stats interval');
                  clearInterval(statsInterval);
                  return;
                }

                // Log the connection state
                const recvState = recvTransport.connectionState;
                const sendState = sendTransport.connectionState;
                debugClient(`[webrtcStats] Transport states - recv: ${recvState}, send: ${sendState}`);
                
                if (recvState === 'connected' && sendState === 'connected') {
                  log(`‚úÖ WebRTC connection established successfully!`);
                  // Once connected, we can reduce frequency of checks
                  clearInterval(statsInterval);
                  
                  // Start connection monitoring at regular intervals
                  lastConnectedTime = Date.now();
                  connectionMonitorInterval = setInterval(monitorConnection, 10000);
                  
                  // Start media connection monitoring to keep ICE alive
                  monitorMediaConnection();
                  
                  // Keep checking less frequently
                  setInterval(() => {
                    const rs = recvTransport.connectionState;
                    const ss = sendTransport.connectionState;
                    if (rs !== 'connected' || ss !== 'connected') {
                      log(`‚ö†Ô∏è WebRTC connection changed: recv=${rs}, send=${ss}`);
                    }
                  }, 15000);
                } else if (recvState !== 'connected' || sendState !== 'connected') {
                  log(`üìä Transport states: recv=${recvState}, send=${sendState}`);
                }

                // For WebRTC internals debugging
                if (recvTransport.handler && recvTransport.handler._pc) {
                  const pc = recvTransport.handler._pc;
                  const stats = await pc.getStats();
                  let hasActiveCandidate = false;
                  let candidatePairs = [];

                  stats.forEach(stat => {
                    if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {
                      hasActiveCandidate = true;
                      candidatePairs.push(`${stat.localCandidateId} <-> ${stat.remoteCandidateId} (${stat.state})`);
                    }
                  });

                  if (!hasActiveCandidate && (recvState !== 'connected' || sendState !== 'connected')) {
                    debugClient('[webrtcStats] No active candidate pairs found. This indicates NAT traversal issues.');
                    log('‚ö†Ô∏è NAT traversal issue detected. Check firewall settings.');
                  } else if (hasActiveCandidate) {
                    debugClient(`[webrtcStats] Active candidate pairs: ${candidatePairs.join(', ')}`);
                    log('üîÑ ICE candidate pairs established successfully.');
                  }
                }
              } catch (e) {
                debugClient('[webrtcStats] Error collecting stats:', e);
              }
            }, 5000);
            
            // Set timeout to attempt reconnection if not connected after 45 seconds
            setTimeout(() => {
              if (recvTransport && sendTransport && 
                  (recvTransport.connectionState !== 'connected' || 
                   sendTransport.connectionState !== 'connected')) {
                log('‚ö†Ô∏è Connection not established after 45 seconds. Attempting reconnection...');
                // Close existing transports
                if (recvTransport) {
                  recvTransport.close();
                  recvTransport = null;
                }
                if (sendTransport) {
                  sendTransport.close();
                  sendTransport = null;
                }
                
                // Reload the device and try again
                log('üîÑ Reloading device and recreating transports...');
                joinSFU();
              }
            }, 45000);
          }, 20000); // Initial 20 second wait
        }

        async function makeTransport(direction, options = {}) {
          try {
            debugClient(`[makeTransport] Requesting server to create ${direction} transport...`);
            
            // Get TURN credentials from server - always fetch fresh credentials
            let iceServersToUse = stunServers;
            try {
              log('üîÑ Fetching fresh TURN credentials...');
              // Fetch with cache busting to ensure we get fresh credentials
              const cacheBuster = Date.now();
              const turnResponse = await fetch(`/api/turn-credentials?t=${cacheBuster}`);
              if (turnResponse.ok) {
                const turnData = await turnResponse.json();
                if (turnData.iceServers && turnData.iceServers.length > 0) {
                  // Enhanced logging of ice servers
                  debugClient(`[makeTransport] Raw Twilio ICE servers response: ${JSON.stringify(turnData.iceServers)}`);
                  
                  // Log details of each ICE server
                  turnData.iceServers.forEach((server, idx) => {
                    const urls = Array.isArray(server.urls) ? server.urls.join(', ') : server.urls;
                    debugClient(`[makeTransport] ICE Server ${idx + 1}: ${urls}`);
                    if (server.credential) {
                      // Don't log actual credentials for security
                      debugClient(`[makeTransport] Server ${idx + 1} has credentials: YES (redacted)`);
                    }
                    // Log if it's a TURN server
                    if (urls && urls.includes('turn:')) {
                      debugClient(`[makeTransport] Server ${idx + 1} is a TURN server`);
                    }
                  });
                  
                  // Use just the servers we got from Twilio - they should have valid credentials
                  iceServersToUse = turnData.iceServers;
                  debugClient(`[makeTransport] Using only Twilio ICE servers: ${iceServersToUse.length} servers`);
                  log(`üåê Using fresh Twilio TURN/STUN servers`);
                } else {
                  debugClient('[makeTransport] No ICE servers returned from Twilio, using fallback STUN servers');
                  log(`‚ö†Ô∏è Using fallback STUN servers only`);
                }
              } else {
                debugClient('[makeTransport] Failed to fetch TURN credentials, using fallback STUN servers');
                log(`‚ö†Ô∏è Using fallback STUN servers only`);
              }
            } catch (e) {
              debugClient('[makeTransport] Error fetching TURN credentials:', e);
              log(`‚ö†Ô∏è Using fallback STUN servers only`);
            }
            
            // ALWAYS use our guaranteed ICE servers
            // If iceServersToUse is empty or has less than 2 servers, add fallback servers
            if (!iceServersToUse || iceServersToUse.length < 2) {
              log(`‚ö†Ô∏è No ICE servers from API, using hardcoded fallbacks`);
              iceServersToUse = [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun.stunprotocol.org:3478' }
              ];
            }
            
            // CRITICAL FIX: Force add Twilio TURN servers for guaranteed connectivity
            const hasTurnServer = iceServersToUse.some(server => {
              const urls = Array.isArray(server.urls) ? server.urls : [server.urls];
              return urls.some(url => url.startsWith('turn:'));
            });
            
            if (!hasTurnServer) {
              log(`üåê Adding TCP TURN fallbacks for firewall compatibility`);
              iceServersToUse.push(
                {
                  urls: 'turn:global.turn.twilio.com:3478?transport=tcp',
                  username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                  credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                },
                {
                  urls: 'turns:global.turn.twilio.com:443?transport=tcp',
                  username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                  credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                }
              );
            }

            log(`üåê Using TCP TURN for firewall compatibility`);
            
            // Use the server response without modification
            const serverResponse = await protooRequest('createWebRtcTransport', {
              producing: direction === 'send',
              consuming: direction === 'recv',
              // Include SCTP capabilities (for data channels)
              sctpCapabilities: device.sctpCapabilities || undefined,
              // Add a flag to request forced TCP mode on server
              forceTcp: true
            });
            
            // CRITICAL DEBUG: Log the exact server response format
            console.log(`[makeTransport] Raw server response for ${direction} transport:`, JSON.stringify(serverResponse));
            
            // Check if response needs to be unwrapped (protoo protocol format fix)
            if (serverResponse && typeof serverResponse === 'object') {
              // Check for empty response but with transportData field
              if ((!serverResponse.id || Object.keys(serverResponse).length === 0) && 
                   serverResponse.transportData && typeof serverResponse.transportData === 'object') {
                console.log(`[makeTransport] Found transportData field, using it directly`, serverResponse.transportData);
                serverResponse = serverResponse.transportData;
              }
              // Check for nested response format (protoo standard)
              else if (serverResponse.response && typeof serverResponse.response === 'object' && serverResponse.response.id) {
                debugClient(`[makeTransport] Found nested response format, unwrapping`);
                serverResponse = serverResponse.response;
              }
            }
            
            debugClient(`[makeTransport] Raw response from server for createWebRtcTransport (${direction}):`, JSON.parse(JSON.stringify(serverResponse))); // Log the raw response

            if (!serverResponse || !serverResponse.id) {
              const errorMsg = 'missing id in server response for createWebRtcTransport';
              console.error(`[makeTransport] ${errorMsg}`, serverResponse);
              log(`‚ùå ${errorMsg}`);
              throw new Error(errorMsg);
            }

            const { id: transportId, iceParameters, iceCandidates, dtlsParameters, sctpParameters } = serverResponse;
            debugClient(`[makeTransport] Server created ${direction} transport, (client-side transportId will be): ${transportId}`);

            // Add special browser detection for Edge/Safari
            const isEdgeOrSafari = /Edge/.test(navigator.userAgent) || /Safari/.test(navigator.userAgent);
            
            const transportOptions = {
              id: transportId,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              // IMPORTANT: Always use our explicit ICE servers, not from response
              iceServers: iceServersToUse,
              // Default to TCP in high-latency scenarios
              iceTransportPolicy: 'all',
              additionalSettings: {
                sdpSemantics: 'unified-plan',
                enableDtlsSrtp: true,
                iceCandidatePoolSize: 10, // Increase candidate pool
                iceCheckMinInterval: 250, // Faster ICE checks (in milliseconds)
                // Force Firefox to use small MTU for better firewall compatibility
                flags: {
                  preferTcp: true, // Prefer TCP connectivity
                  enableIpv6: false, // Disable IPv6 for faster fallback
                  disableIPv6: true,
                  enableTurnTcp: true // Enable turn over TCP explicitly
                },
                // Add Edge/Safari specific settings
                ...(isEdgeOrSafari ? {
                  // More aggressive ICE for problematic browsers
                  iceAggressiveNomination: true,
                  iceKeepaliveInterval: 2000, // faster keepalives
                } : {})
              }
            };
            
            // Force IPv4 for better compatibility
            if (typeof RTCPeerConnection !== 'undefined' && 
                typeof RTCPeerConnection.prototype.addTransceiver === 'function') {
              transportOptions.additionalSettings.icePreferIpv4 = true;
              transportOptions.additionalSettings.iceNetworkTypes = ['ethernet', 'wifi'];
              
              // Force TCP preference in Chrome
              if (/Chrome/.test(navigator.userAgent)) {
                transportOptions.iceTcpMux = true; // Enable TCP muxing if available
              }
            }
            
            debugClient(`[makeTransport] Using transportOptions for ${direction} transport:`, JSON.parse(JSON.stringify(transportOptions))); // Log the options

            const transport = direction === 'send' ?
              device.createSendTransport(transportOptions) :
              device.createRecvTransport(transportOptions);

            debugClient(`[makeTransport] Client-side ${direction} transport created: ${transport.id}`);
            
            // Store creation time to detect stalled transports
            transport._createdAt = Date.now();

            transport.on('connect', async ({ dtlsParameters: connectDtlsParameters }, callback, errback) => {
              try {
                debugClient(`[transport ${direction} ${transport.id}] 'connect' event. DtlsParameters:`, connectDtlsParameters);
                await protooRequest('connectWebRtcTransport', { transportId: transport.id, dtlsParameters: connectDtlsParameters });
                debugClient(`[transport ${direction} ${transport.id}] Server acknowledged 'connectWebRtcTransport'.`);
                callback();
              } catch (error) {
                console.error(`[transport ${direction} ${transport.id}] 'connect' error:`, error);
                log(`‚ùå Error connecting ${direction} transport: ${error.message}`);
                errback(error);
              }
            });

            if (direction === 'send') {
              transport.on('produce', async ({ kind, rtpParameters, appData }, callback, errback) => {
                try {
                  debugClient(`[transport send ${transport.id}] 'produce' event. Kind: ${kind}, RtpParameters:`, rtpParameters, 'AppData:', appData);
                  const { id: producerId } = await protooRequest('produce', { transportId: transport.id, kind, rtpParameters, appData });
                  debugClient(`[transport send ${transport.id}] Server created producer: ${producerId} for kind ${kind}`);
                  callback({ id: producerId });
                } catch (error) {
                  console.error(`[transport send ${transport.id}] 'produce' error:`, error);
                  log(`‚ùå Error producing ${kind}: ${error.message}`);
                  errback(error);
                }
              });
            }

            transport.on('connectionstatechange', (state) => {
              console.log(`[transport ${direction} ${transport.id}] connection state changed to ${state}`);
              log(`üîÅ ${direction.charAt(0).toUpperCase() + direction.slice(1)} transport connection state: ${state}`);
              
              // Add special handling for "new" state that doesn't progress
              if (state === 'new') {
                // Set a timer to check if we're stuck in "new" state
                transport._newStateTimer = setTimeout(() => {
                  if (transport.connectionState === 'new') {
                    // Still in "new" state after delay - force recreation
                    debugClient(`[transport ${direction}] Stuck in "new" state for 10s, forcing recreation`);
                    log(`‚ö†Ô∏è ${direction} transport stuck in "new" state. Forcing recreation...`);
                    
                    // Close and recreate transport
                    if (typeof refreshTransport === 'function') {
                      refreshTransport(direction, true);  // true = force TURN mode
                    }
                  }
                }, 10000); // 10 second timeout for "new" state
              } else {
                // Clear the timer if state progresses
                if (transport._newStateTimer) {
                  clearTimeout(transport._newStateTimer);
                  transport._newStateTimer = null;
                }
              }
              
              if (state === 'failed' || state === 'closed' || state === 'disconnected') {
                // Handle transport failure, maybe notify user or attempt reconnection
                console.warn(`[transport ${direction} ${transport.id}] Transport ${state}.`);
                // For now, just log. In a real app, might want to clean up or retry.
              }
            });
            
            transport.on('icecandidate', (candidate) => {
                debugClient(`[transport ${direction} ${transport.id}] ICE candidate:`, candidate);
                // In a typical client-server model with an SFU, you don't usually send ICE candidates
                // from client to server *after* initial transport creation, as the server provides its candidates.
                // However, some SFU designs might expect trickle ICE from client. Mediasoup-demo usually doesn't.
            });

            // Add an explicit debug log for ice gathering state changes
            transport.on('icegatheringstatechange', (state) => {
              debugClient(`[transport ${direction} ${transport.id}] ICE gathering state changed to ${state}`);
              log(`üßä ${direction.charAt(0).toUpperCase() + direction.slice(1)} transport ICE gathering: ${state}`);
            });

            // Monitor ICE candidates more closely
            if (transport.handler && transport.handler._pc) {
              const pc = transport.handler._pc;
              
              pc.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                  debugClient(`[transport ${direction}] New ICE candidate: ${event.candidate.candidate}`);
                  const candidateInfo = event.candidate.candidate.split(' ');
                  if (candidateInfo.length > 7) {
                    const type = candidateInfo[7]; // typ host/srflx/relay
                    log(`üßä New ${type} ICE candidate for ${direction} transport`);
                  }
                } else {
                  log(`üßä ICE candidate gathering complete for ${direction} transport`);
                }
              });

              pc.addEventListener('connectionstatechange', () => {
                log(`üîå PeerConnection state (${direction}): ${pc.connectionState}`);
                
                // Special handling for Edge browser to force TURN if direct connection fails
                if (pc.connectionState === 'checking' && /Edge/.test(navigator.userAgent)) {
                  // In Edge, if we're stuck in checking, try forcing TURN
                  setTimeout(() => {
                    if (pc.connectionState === 'checking' || pc.connectionState === 'new') {
                      log(`‚ö†Ô∏è Edge browser detected with stuck connection. Trying to force TURN...`);
                      // Force recreation with TURN only
                      if (typeof refreshTransport === 'function') {
                        refreshTransport(direction, true); // true = force TURN
                      }
                    }
                  }, 8000); // Give it 8 seconds to connect
                }
              });

              pc.addEventListener('icecandidateerror', (event) => {
                log(`‚ùå ICE candidate error: ${event.errorText || 'Unknown error'}`);
              });
              
              // Force STUN/TURN requests to happen faster
              if (pc.setConfiguration && typeof pc.getConfiguration === 'function') {
                try {
                  const currentConfig = pc.getConfiguration();
                  
                  // Apply the iceTransportPolicy if specified in options
                  if (options.iceTransportPolicy) {
                    debugClient(`[makeTransport] Setting iceTransportPolicy to ${options.iceTransportPolicy}`);
                    pc.setConfiguration({
                      ...currentConfig,
                      iceTransportPolicy: options.iceTransportPolicy,
                      iceCandidatePoolSize: 10,
                      bundlePolicy: 'max-bundle',
                      rtcpMuxPolicy: 'require'
                    });
                  } else {
                    pc.setConfiguration({
                      ...currentConfig,
                      iceTransportPolicy: 'all',
                      iceCandidatePoolSize: 10,
                      bundlePolicy: 'max-bundle',
                      rtcpMuxPolicy: 'require'
                    });
                  }
                } catch (e) {
                  debugClient(`[transport ${direction}] Error setting configuration: ${e.message}`);
                }
              }
            }

            return transport;
          } catch (error) {
            console.error(`[makeTransport] Error in makeTransport(${direction}):`, error);
            log(`‚ùå Error creating ${direction} transport: ${error.message}`);
            throw error; // Re-throw to be caught by joinSFU
          }
        }

        // After transports have been created and we're about to process pending consumers
        async function processPendingConsumers() {
          debugClient(`Processing ${pendingProducersToConsume.length} pending producers to consume.`);
          if (pendingProducersToConsume.length === 0) return;

          // Check if WebRTC is likely to be blocked based on previous errors
          if (window._webrtcFailures && window._webrtcFailures > 3) {
            debugClient('[processPendingConsumers] WebRTC appears to be blocked, using WebSocket fallback');
            log('‚ö†Ô∏è WebRTC appears to be blocked. Using WebSocket fallback mode.');
            setupWebSocketFallback();
            return;
          }

          // First verify that the receive transport is ready
          if (!recvTransport || recvTransport.connectionState === 'failed' || recvTransport.connectionState === 'closed') {
            debugClient('[processPendingConsumers] Receive transport not ready, attempting to recreate');
            log('‚ö†Ô∏è Receive transport not ready, recreating before consuming...');
            
            try {
              if (recvTransport) {
                try { recvTransport.close(); } catch (e) {}
                recvTransport = null;
              }
              
              recvTransport = await makeTransport('recv');
              log(`‚úÖ New receive transport created for pending consumers: ${recvTransport.id}`);
              
              // Wait a moment for transport to initialize
              await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
              debugClient(`[processPendingConsumers] Failed to recreate transport: ${e.message}`);
              log(`‚ùå Failed to recreate receive transport: ${e.message}`);
              
              // Count WebRTC failures
              if (!window._webrtcFailures) window._webrtcFailures = 1;
              else window._webrtcFailures++;
              
              // Try WebSocket fallback if WebRTC keeps failing
              if (window._webrtcFailures > 2) {
                debugClient('[processPendingConsumers] Multiple WebRTC failures, trying WebSocket fallback');
                log('‚ö†Ô∏è WebRTC seems blocked. Trying WebSocket fallback mode...');
                setupWebSocketFallback();
                return;
              }
              
              // Try again later
              setTimeout(processPendingConsumers, 5000);
              return;
            }
          }
          
          // Check for Edge browser with "new" transport state
          if (/Edge/.test(navigator.userAgent) && recvTransport.connectionState === 'new') {
            // For Edge, we need special handling as it often gets stuck in "new" state
            debugClient('[processPendingConsumers] Edge browser with transport in "new" state detected');
            
            // If transport has been in "new" state for more than 5 seconds, force a recreation
            if (recvTransport._createdAt && (Date.now() - recvTransport._createdAt > 5000)) {
              debugClient('[processPendingConsumers] Edge transport stuck in "new" state, forcing recreation with TURN');
              log('‚ö†Ô∏è Edge browser detected with stuck connection. Forcing TURN...');
              
              try {
                if (recvTransport) {
                  try { recvTransport.close(); } catch (e) {}
                  recvTransport = null;
                }
                
                // Use the enhanced refreshTransport with forceTurn=true
                if (typeof refreshTransport === 'function') {
                  await refreshTransport('recv', true);
                  // Wait a moment for the new transport
                  await new Promise(resolve => setTimeout(resolve, 1000));
                }
              } catch (e) {
                debugClient(`[processPendingConsumers] Error recreating transport for Edge: ${e.message}`);
                
                // Try again later
                setTimeout(processPendingConsumers, 5000);
                return;
              }
            } else {
              // If it's a new transport, set creation timestamp for future checks
              if (!recvTransport._createdAt) {
                recvTransport._createdAt = Date.now();
              }
              
              // Try again shortly to see if state changes
              setTimeout(processPendingConsumers, 2000);
              return;
            }
          }

          const producersToProcess = [...pendingProducersToConsume];
          pendingProducersToConsume = []; // Clear queue before processing to avoid re-entrancy issues
          debugClient(`Cleared pendingProducersToConsume queue. Now processing ${producersToProcess.length} producers.`);

          // Process in sequence to avoid overwhelming the connection
          for (const producerInfo of producersToProcess) {
            debugClient(`Calling consumeProducer for queued producer: ${producerInfo.producerId}`);
            try {
              await consumeProducer(producerInfo);
              // Small delay between consumers to help with stability
              await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
              debugClient(`Error consuming producer ${producerInfo.producerId}: ${e.message}`);
              // Add back to queue
              pendingProducersToConsume.push(producerInfo);
            }
          }
          debugClient(`Finished processing ${producersToProcess.length} pending producers.`);
        }

        async function consumeProducer(producerInfo) {
          const { peerId: producerPeerId, producerId, kind, appData } = producerInfo;
          debugClient(`[consumeProducer] START for producerId: ${producerId} from peer ${producerPeerId}`);
          console.log('üÜï consuming new producer notification', producerId, kind, appData, 'from peer', producerPeerId);
          log(`üÜï Seeing new producer: ${producerId} (${kind}) from peer ${producerPeerId}`);
          try {
            if (!device || !device.loaded) {
              const errorMsg = 'Device not loaded at consumeProducer call';
              console.warn(`${errorMsg} for ${producerId}`);
              log(`‚ö†Ô∏è ${errorMsg} for ${producerId}`);
              // Queue it to try again later instead of just returning
              pendingProducersToConsume.push(producerInfo);
              return;
            }
            
            // Make sure we have a recv transport
            if (!recvTransport) {
              const errorMsg = 'Receive transport not ready, cannot consume';
              console.warn(`${errorMsg}. ProducerId: ${producerId}`);
              log(`‚ö†Ô∏è ${errorMsg} for ${producerId}`);
              
              // If we were previously connected but lost the transport, try to recreate it
              if (device.loaded) {
                log(`üîÑ Attempting to recreate receive transport...`);
                try {
                  recvTransport = await makeTransport('recv');
                  log(`üëç Recreated receive transport: ${recvTransport.id}`);
                  
                  // Update stored transport ID
                  if (window._transportIds) {
                    window._transportIds.recv = recvTransport.id;
                    window._transportIds.timestamp = Date.now();
                    try {
                      localStorage.setItem('mediasoup_transport_ids', JSON.stringify(window._transportIds));
                    } catch (e) {
                      console.error('Error saving transport IDs to localStorage:', e);
                    }
                  }
                  
                  // Now continue with consumption after a slight delay
                  setTimeout(() => consumeProducer(producerInfo), 500);
                  return;
                } catch (recreateErr) {
                  console.error('Failed to recreate receive transport', recreateErr);
                  log(`‚ùå Failed to recreate receive transport: ${recreateErr.message}`);
                  return;
                }
              }
              // If we couldn't recreate, just queue for later
              pendingProducersToConsume.push(producerInfo);
              return;
            }
            
            // Verify that transport ID is still valid on server
            const transportId = recvTransport.id;
            if (!isTransportValid('recv', transportId)) {
              debugClient(`[consumeProducer] Transport ID ${transportId} may be invalid (doesn't match stored ID)`);
              log(`‚ö†Ô∏è Transport ID validation failed. Recreating transport...`);
              
              try {
                recvTransport.close();
              } catch (e) {
                debugClient(`[consumeProducer] Error closing possibly invalid transport: ${e.message}`);
              }
              
              recvTransport = null;
              
              // Try to create a new transport
              try {
                // Check if we need to use Edge-specific settings
                const isEdge = /Edge/.test(navigator.userAgent) || /Edg/.test(navigator.userAgent);
                if (isEdge) {
                  const turnOptions = {
                    iceTransportPolicy: 'relay',
                    additionalIceServers: [
                      {
                        urls: 'turn:turn.webrtc.org:3478',
                        username: 'webrtc',
                        credential: 'turnserver'
                      },
                      {
                        urls: 'turn:global.turn.twilio.com:3478?transport=udp',
                        username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                        credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                      }
                    ]
                  };
                  recvTransport = await makeTransport('recv', turnOptions);
                } else {
                  recvTransport = await makeTransport('recv');
                }
                
                // Update stored transport ID
                if (window._transportIds) {
                  window._transportIds.recv = recvTransport.id;
                  window._transportIds.timestamp = Date.now();
                  try {
                    localStorage.setItem('mediasoup_transport_ids', JSON.stringify(window._transportIds));
                  } catch (e) {
                    console.error('Error saving transport IDs to localStorage:', e);
                  }
                }
                
                log(`üëç Created new receive transport: ${recvTransport.id}`);
                setTimeout(() => consumeProducer(producerInfo), 500);
                return;
              } catch (createErr) {
                console.error('Error creating new receive transport:', createErr);
                log(`‚ùå Failed to create receive transport: ${createErr.message}`);
                pendingProducersToConsume.push(producerInfo);
                return;
              }
            }

            try {
              // Verify transport exists on server with a ping first
              try {
                await protooRequest('ping', { 
                  clientTime: Date.now(),
                  transportId: recvTransport.id
                });
              } catch (pingErr) {
                // If ping fails with an error mentioning the transport, the transport is likely gone
                if (pingErr.message && pingErr.message.toLowerCase().includes('transport')) {
                  throw new Error(`Transport ping failed: ${pingErr.message}`);
                }
                // Otherwise, just a general ping failure, we can still try to consume
              }
              
              const { id: consumerId, producerId: remoteProducerIdReturned, kind: remoteKind, rtpParameters } = await protooRequest('consume', {
                rtpCapabilities: device.rtpCapabilities,
                producerId,
                transportId: recvTransport.id  // Explicitly include transport ID
              });
              
              // Successfully got consumer from server
              debugClient(`[consumeProducer] Server created consumer ${consumerId} for producer ${producerId}`);
              
              const consumer = await recvTransport.consume({
                id: consumerId,
                producerId: remoteProducerIdReturned, 
                kind: remoteKind, 
                rtpParameters: rtpParameters,
              });
              
              log(`üéß Consuming remote stream: ${producerId}`);
              debugClient(`[consumeProducer] Consumer ${consumer.id} created for producer ${producerId}. Initial client state: paused=${consumer.paused}, track=${!!consumer.track}`);
              
              await protooRequest('resumeConsumer', { consumerId: consumer.id });
              debugClient(`[consumeProducer] Server acknowledged resume request for consumer ${consumer.id}`);
              
              consumer.resume();
              log(`‚ñ∂Ô∏è Resumed remote stream: ${producerId}`);
              debugClient(`[consumeProducer] Client-side consumer.resume() called for ${consumer.id}. New client state: paused=${consumer.paused}, track=${!!consumer.track}`);

              // Store consumer in window for recovery purposes
              if (!window._consumers) window._consumers = {};
              window._consumers[producerId] = consumer;
              
              // Schedule a delayed second resume attempt - this often helps with Edge browser
              setTimeout(async () => {
                try {
                  if (consumer && consumer.closed !== true) {
                    debugClient(`[consumeProducer] Doing delayed resume for consumer ${consumer.id}`);
                    await protooRequest('resumeConsumer', { consumerId: consumer.id });
                    consumer.resume();
                    log(`üîÑ Re-established media flow for ${producerId}`);
                  }
                } catch (e) {
                  debugClient(`[consumeProducer] Error in delayed resume: ${e.message}`);
                }
              }, 3000); // Try again after 3 seconds

              function attachTrackToVideo(track, producerId) {
                  if (!track || track.readyState !== 'live') {
                      debugClient(`[attachTrackToVideo] Track ${track?.id} is not live. State: ${track ? track.readyState : 'no track'}`);
                      log(`‚ö†Ô∏è Remote track for ${producerId} not live.`);
                      return;
                  }
                  debugClient(`[attachTrackToVideo] Track ${track.id} is live. Attaching to remoteVideo.`);
                  
                  // Simplest assignment: Create a new MediaStream with just this track
                  if (!remoteVideo.srcObject) {
                      remoteVideo.srcObject = new MediaStream();
                  }
                  
                  // Add this track to existing stream if it doesn't already exist
                  const stream = remoteVideo.srcObject;
                  const existingTrack = stream.getTracks().find(t => t.id === track.id);
                  if (!existingTrack) {
                      stream.addTrack(track);
                  }
                  
                  debugClient(`[attachTrackToVideo] remoteVideo.srcObject assigned with stream containing ${stream.getTracks().length} tracks`);
                  
                  // CRITICAL FIX: Set display style to ensure video element is visible
                  remoteVideo.style.display = 'block';
                  
                  // Add the detailed logging for tracks *after* assignment
                  if (stream && typeof stream.getTracks === 'function') {
                      const tracks = stream.getTracks();
                      debugClient(`[attachTrackToVideo] MediaStream now has ${tracks.length} track(s).`);
                      tracks.forEach((t, index) => {
                          debugClient(`[attachTrackToVideo] Track ${index}: id=${t.id}, kind=${t.kind}, label='${t.label}', enabled=${t.enabled}, muted=${t.muted}, readyState=${t.readyState}`);
                          
                          // Add per-track monitoring for stable media flow
                          monitorTrack(t, producerId);
                          
                          // Show visual indicator for receiving video bytes, but add class to show it's not rendering frames
                          if (t.kind === 'video') {
                              remoteVideo.classList.add('receiving-video-data');
                              
                              // Create a bytes-but-no-frames indicator
                              const indicator = document.createElement('div');
                              indicator.id = 'bytesNoFramesIndicator';
                              indicator.style.display = 'none'; // Hidden by default
                              indicator.style.position = 'absolute';
                              indicator.style.top = '10px';
                              indicator.style.left = '10px';
                              indicator.style.backgroundColor = 'rgba(255,0,0,0.7)';
                              indicator.style.color = 'white';
                              indicator.style.padding = '5px';
                              indicator.style.borderRadius = '5px';
                              indicator.textContent = 'Receiving bytes but no frames';
                              document.body.appendChild(indicator);
                              
                              // Keep track of this indicator in window scope
                              window._bytesNoFramesIndicator = indicator;
                          }
                          
                          // If track is muted, try to unmute after a short delay
                          if (t.muted) {
                              debugClient(`[attachTrackToVideo] Track ${index} is muted, will try to unmute shortly...`);
                              log(`üîá Remote track is muted, waiting for media...`);
                              
                              // Check muted state periodically
                              let unmuteTries = 0;
                              const maxTries = 60; // 60 seconds max
                              const checkInterval = setInterval(() => {
                                  if (!t.muted || unmuteTries >= maxTries) {
                                      if (!t.muted) {
                                          debugClient(`[attachTrackToVideo] Track ${t.id} unmuted after ${unmuteTries} tries!`);
                                          log(`üîä Remote media flowing now!`);
                                      } else {
                                          debugClient(`[attachTrackToVideo] Track ${t.id} still muted after ${maxTries} tries.`);
                                          log(`‚ö†Ô∏è Remote media still muted after ${maxTries} seconds. Attempting recovery...`);
                                          attemptTrackRecovery(producerId);
                                      }
                                      clearInterval(checkInterval);
                                  }
                                  unmuteTries++;
                              }, 1000);
                          }
                      });
                  } else {
                      debugClient(`[attachTrackToVideo] remoteVideo.srcObject is null/undefined after new MediaStream assignment.`);
                  }

                  // Try to play and handle autoplay restrictions
                  playVideoWithFallback(remoteVideo, producerId);
              }
              
              function playVideoWithFallback(videoElement, trackId) {
                  videoElement.play().then(() => {
                      debugClient(`[playVideoWithFallback] Video play() successful for ${trackId}`);
                      log(`üñºÔ∏è Displaying remote stream: ${trackId}`);
                  }).catch(e => {
                      debugClient(`[playVideoWithFallback] Video play() failed for ${trackId}: ${e.message}`);
                      log(`‚ö†Ô∏è Could not autoplay video for ${trackId}. Adding UI controls.`);
                      
                      // Add controls and make visible in case of autoplay restrictions
                      videoElement.controls = true;
                      videoElement.muted = true; // Muted videos can autoplay
                      
                      // Try again with mute 
                      videoElement.play().then(() => {
                          debugClient(`[playVideoWithFallback] Muted play successful for ${trackId}`);
                          log(`üñºÔ∏è Displaying muted stream, click to unmute`);
                          
                          // Add click handler to unmute
                          videoElement.addEventListener('click', function unmute() {
                              videoElement.muted = false;
                              videoElement.removeEventListener('click', unmute);
                              log(`üîä Unmuted stream: ${trackId}`);
                          });
                      }).catch(err => {
                          debugClient(`[playVideoWithFallback] Even muted play failed: ${err.message}`);
                          log(`‚ùå Cannot play video even muted. Check browser settings.`);
                      });
                  });
              }

              if (consumer.track) {
                  attachTrackToVideo(consumer.track, producerId);
              } else {
                  debugClient(`[consumeProducer] Track for consumer ${consumer.id} not immediately available after resume. Listening for 'trackstart'.`);
                  consumer.once('trackstart', () => {
                      debugClient(`[consumeProducer] 'trackstart' event received for consumer ${consumer.id}.`);
                      attachTrackToVideo(consumer.track, producerId);
                  });
              }
              
              consumer.on('trackended', () => {
                  debugClient(`[consumeProducer] Consumer ${consumer.id} track ended. Clearing remote video.`);
                  log(`üö´ Remote stream ended: ${producerId}`);
                  if (remoteVideo.srcObject && typeof remoteVideo.srcObject.getTracks === 'function') {
                      const stream = remoteVideo.srcObject;
                      stream.getTracks().forEach(t => {
                          if (t.id === consumer.track.id) {
                              stream.removeTrack(t);
                          }
                      });
                      if (stream.getTracks().length === 0) {
                          remoteVideo.srcObject = null;
                      }
                  }
              });
              consumer.on('producerpause', () => {
                  debugClient(`[consumeProducer] Producer for consumer ${consumer.id} paused.`);
                  log(`‚è∏Ô∏è Remote stream paused: ${producerId}`);
              });
              consumer.on('producerresume', () => {
                  debugClient(`[consumeProducer] Producer for consumer ${consumer.id} resumed.`);
                  log(`‚ñ∂Ô∏è Remote stream resumed by producer: ${producerId}`);
              });

            } catch (innerErr) {
              // Handle specific transport errors
              if (innerErr.message && (
                  innerErr.message.includes('Channel request handler with ID') || 
                  innerErr.message.includes('transport') || 
                  innerErr.message.includes('not found'))) {
                
                debugClient(`[consumeProducer] Transport error detected: ${innerErr.message}`);
                log(`üîÑ Transport error detected. Recreating transport...`);
                
                // Mark transport as invalid to force recreation on next attempt
                if (window._transportIds && window._transportIds.recv === recvTransport.id) {
                  window._transportIds.recv = null;
                }
                
                // Close and nullify the receive transport
                if (recvTransport) {
                  try {
                    recvTransport.close();
                  } catch (e) {
                    debugClient(`[consumeProducer] Error closing receive transport: ${e.message}`);
                  }
                  recvTransport = null;
                }
                
                // Recreate the transport after a short delay
                setTimeout(async () => {
                  try {
                    log(`üîÑ Creating new receive transport after error...`);
                    const isEdge = /Edge/.test(navigator.userAgent) || /Edg/.test(navigator.userAgent);
                    if (isEdge) {
                      const turnOptions = {
                        iceTransportPolicy: 'relay',
                        additionalIceServers: [
                          {
                            urls: 'turn:turn.webrtc.org:3478',
                            username: 'webrtc',
                            credential: 'turnserver'
                          },
                          {
                            urls: 'turn:global.turn.twilio.com:3478?transport=udp',
                            username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                            credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                          }
                        ]
                      };
                      recvTransport = await makeTransport('recv', turnOptions);
                    } else {
                      recvTransport = await makeTransport('recv');
                    }
                    
                    // Update stored ID
                    storeTransportIds(
                      window._transportIds && window._transportIds.send ? window._transportIds.send : null,
                      recvTransport.id
                    );
                    
                    log(`‚úÖ Successfully created new receive transport: ${recvTransport.id}`);
                    
                    // Try consuming again
                    setTimeout(() => {
                      pendingProducersToConsume.push(producerInfo);
                      processPendingConsumers();
                    }, 500);
                  } catch (recreateErr) {
                    debugClient(`[consumeProducer] Failed to recreate transport: ${recreateErr.message}`);
                    log(`‚ùå Failed to recreate transport: ${recreateErr.message}`);
                    
                    // Queue for later retry
                    pendingProducersToConsume.push(producerInfo);
                  }
                }, 1000);
              } else {
                // Other errors
                console.error(`Error consuming producer ${producerId}:`, innerErr);
                log(`‚ùå ERROR consuming producer ${producerId}: ${innerErr.message}`);
                
                // Still queue for retry
                pendingProducersToConsume.push(producerInfo);
              }
            }
          } catch (err) {
            console.error(`Error in consume request for producer ${producerId}:`, err);
            log(`‚ùå ERROR consuming producer ${producerId}: ${err.message}`);
            
            // Add to queue for retry
            pendingProducersToConsume.push(producerInfo);
          }
          debugClient(`[consumeProducer] END for producerId: ${producerId}`);
        }

        // Function to monitor track for dropped frames or freezes
        function monitorTrack(track, producerId) {
            // Don't monitor audio tracks
            if (track.kind !== 'video') return;
            
            let lastFrames = 0;
            let lastTimestamp = Date.now();
            let staleFrameCount = 0;
            // Use more patience for novideo clients since they might need more time to establish proper receiving
            const MAX_STALE_FRAMES = !wantsVideo ? 15 : 5; // Higher threshold for receive-only clients
            let initialGracePeriod = true;
            
            // For receive-only clients, delay monitoring to give the connection time to stabilize
            if (!wantsVideo) {
                setTimeout(() => {
                    initialGracePeriod = false;
                    debugClient(`[monitorTrack] Initial grace period ended for receive-only client`);
                }, 15000); // 15 second grace period for receive-only clients
            } else {
                initialGracePeriod = false; // No grace period for full participants
            }
            
            const monitor = setInterval(async () => {
                try {
                    // Skip checks during initial grace period for receive-only clients
                    if (initialGracePeriod) {
                        debugClient(`[monitorTrack] In grace period, skipping frame check`);
                        return;
                    }
                    
                    // Check if track still exists and is in the DOM
                    if (!track || track.readyState !== 'live' || !remoteVideo || !remoteVideo.srcObject) {
                        clearInterval(monitor);
                        debugClient(`[monitorTrack] Track ${track.id} no longer available, stopping monitor`);
                        return;
                    }
                    
                    // Get stats from the peer connection (more reliable than track.getStats)
                    if (recvTransport && recvTransport.handler && recvTransport.handler._pc) {
                        try {
                            const pc = recvTransport.handler._pc;
                            const stats = await pc.getStats();
                            
                            let frameInfoFound = false;
                            let currentFrames = null;
                            
                            stats.forEach(stat => {
                                // Look for either inbound-rtp (receiver) or outbound-rtp (sender) statistics
                                if ((stat.type === 'inbound-rtp' || stat.type === 'track') && 
                                    stat.kind === 'video' && 
                                    (stat.framesReceived !== undefined || stat.framesDecoded !== undefined)) {
                                    
                                    // Use whatever frame count is available
                                    currentFrames = stat.framesDecoded || stat.framesReceived;
                                    frameInfoFound = true;
                                    
                                    // For debugging
                                    if (stat.framesReceived !== undefined) {
                                        debugClient(`[monitorTrack] Stats found: framesReceived=${stat.framesReceived}, bytesReceived=${stat.bytesReceived || 'N/A'}`);
                                    }
                                    if (stat.framesDecoded !== undefined) {
                                        debugClient(`[monitorTrack] Stats found: framesDecoded=${stat.framesDecoded}, keyFramesDecoded=${stat.keyFramesDecoded || 'N/A'}`);
                                    }
                                    
                                    // Also check for frozen frames if that stat is available
                                    if (stat.freezeCount !== undefined && stat.freezeCount > 0) {
                                        debugClient(`[monitorTrack] Detected ${stat.freezeCount} video freezes`);
                                        if (stat.freezeCount > 3) {
                                            log(`‚ö†Ô∏è Video appears to be freezing. Attempting recovery...`);
                                            attemptTrackRecovery(producerId);
                                            clearInterval(monitor);
                                            return;
                                        }
                                    }
                                    
                                    // Check for timestamp gaps
                                    const now = Date.now();
                                    const timeDiff = now - lastTimestamp;
                                    lastTimestamp = now;
                                    
                                    if (timeDiff > 5000) {
                                        // More than 5 second gap between stats, could be a problem
                                        debugClient(`[monitorTrack] Large gap (${timeDiff}ms) between stats readings, possible connection issue`);
                                    }
                                }
                            });
                            
                            // Special check for clients receiving video but not sending
                            if (!wantsVideo && currentFrames === 0) {
                                // Check if we're receiving bytes but no frames
                                if (bytesReceived > 0) {
                                    debugClient(`[monitorTrack] Receiving ${bytesReceived} bytes but no frames, possible codec issue`);
                                    
                                    // Show the bytes-but-no-frames indicator
                                    if (window._bytesNoFramesIndicator) {
                                        window._bytesNoFramesIndicator.style.display = 'block';
                                        window._bytesNoFramesIndicator.textContent = `Receiving ${bytesReceived} bytes but no frames`;
                                    }
                                    
                                    // If this is the first time we detect this issue, try a last resort fix
                                    if (!window._triedCodecFallback && bytesReceived > 10000) {
                                        window._triedCodecFallback = true;
                                        
                                        // Try a last resort fix - force the video element to show something
                                        debugClient(`[monitorTrack] Attempting last resort fix for receiving bytes without frames`);
                                        
                                        // Create a dummy canvas to try to force the video to display something
                                        const canvas = document.createElement('canvas');
                                        canvas.width = 320;
                                        canvas.height = 240;
                                        const ctx = canvas.getContext('2d');
                                        
                                        // Draw a simple indicator on the canvas
                                        ctx.fillStyle = 'black';
                                        ctx.fillRect(0, 0, 320, 240);
                                        ctx.fillStyle = 'white';
                                        ctx.font = '14px Arial';
                                        ctx.fillText(`Receiving video data: ${bytesReceived} bytes`, 10, 30);
                                        ctx.fillText('Video stream connected but codec issue detected', 10, 60);
                                        ctx.fillText('You may need to use same browser on both ends', 10, 90);
                                        
                                        // Add canvas to the page as a fallback visual
                                        canvas.style.position = 'absolute';
                                        canvas.style.top = remoteVideo.offsetTop + 'px';
                                        canvas.style.left = remoteVideo.offsetLeft + 'px';
                                        canvas.style.zIndex = '1000';
                                        document.body.appendChild(canvas);
                                        
                                        // Keep updating the bytesReceived count
                                        setInterval(() => {
                                            if (bytesReceived > 0) {
                                                ctx.fillStyle = 'black';
                                                ctx.fillRect(0, 0, 320, 240);
                                                ctx.fillStyle = 'white';
                                                ctx.font = '14px Arial';
                                                ctx.fillText(`Receiving video data: ${bytesReceived} bytes`, 10, 30);
                                                ctx.fillText('Video stream connected but codec issue detected', 10, 60);
                                                ctx.fillText('You may need to use same browser on both ends', 10, 90);
                                                
                                                // Draw a blinking indicator to show it's still working
                                                const now = Date.now();
                                                if (Math.floor(now / 500) % 2 === 0) {
                                                    ctx.fillStyle = 'green';
                                                    ctx.fillRect(10, 120, 20, 20);
                                                }
                                            }
                                        }, 500);
                                        
                                        log(`‚ÑπÔ∏è Video data is being received but can't be decoded by your browser.`);
                                        log(`‚ÑπÔ∏è This is likely a codec compatibility issue between Edge and Chrome.`);
                                        log(`‚ÑπÔ∏è Audio should still work normally.`);
                                    }
                                    
                                    // If we have enough data but no frames, force recovery sooner
                                    if (staleFrameCount >= 3 && bytesReceived > 5000) {
                                        log(`‚ö†Ô∏è Receiving data (${bytesReceived} bytes) but no frames. Forcing stream recovery...`);
                                        clearInterval(monitor);
                                        attemptTrackRecovery(producerId);
                                        return;
                                    }
                                } else {
                                    // Hide the indicator if no bytes received
                                    if (window._bytesNoFramesIndicator) {
                                        window._bytesNoFramesIndicator.style.display = 'none';
                                    }
                                    
                                    debugClient(`[monitorTrack] Zero frames on receive-only client, no bytes received yet`);
                                }
                            }
                            
                            if (frameInfoFound && currentFrames !== null) {
                                if (currentFrames === lastFrames) {
                                    staleFrameCount++;
                                    debugClient(`[monitorTrack] No new frames detected (${staleFrameCount}/${MAX_STALE_FRAMES}). Current: ${currentFrames}, Last: ${lastFrames}`);
                                    
                                    if (staleFrameCount >= MAX_STALE_FRAMES) {
                                        log(`‚ö†Ô∏è Video appears to be frozen (no new frames). Attempting recovery...`);
                                        attemptTrackRecovery(producerId);
                                        clearInterval(monitor);
                                    }
                                } else {
                                    // Frames are changing, all good
                                    staleFrameCount = 0;
                                    debugClient(`[monitorTrack] Frame count changed: ${lastFrames} ‚Üí ${currentFrames}`);
                                }
                                lastFrames = currentFrames;
                            } else {
                                debugClient(`[monitorTrack] No frame info found in stats`);
                                // If we repeatedly can't find stats, that's another kind of problem
                                staleFrameCount++;
                                if (staleFrameCount >= MAX_STALE_FRAMES) {
                                    log(`‚ö†Ô∏è Can't get video stats. Attempting recovery...`);
                                    attemptTrackRecovery(producerId);
                                    clearInterval(monitor);
                                }
                            }
                        } catch (e) {
                            debugClient(`[monitorTrack] Error getting peer connection stats: ${e.message}`);
                        }
                    } else {
                        debugClient(`[monitorTrack] No peer connection available to monitor`);
                    }
                } catch (e) {
                    debugClient(`[monitorTrack] Error monitoring track: ${e.message}`);
                }
            }, 3000); // Check every 3 seconds
            
            // Auto-cleanup after 3 minutes
            setTimeout(() => {
                if (monitor) {
                    clearInterval(monitor);
                    debugClient(`[monitorTrack] Stopping track monitor after timeout`);
                }
            }, 180000);
        }

        // Try to recover a failed track
        async function attemptTrackRecovery(producerId) {
            // Check if we're already attempting recovery for this producer
            if (window._recoveryAttempts && window._recoveryAttempts[producerId]) {
                const lastAttempt = window._recoveryAttempts[producerId];
                const timeSinceLastAttempt = Date.now() - lastAttempt.timestamp;
                
                // Don't retry too frequently - use exponential backoff
                if (timeSinceLastAttempt < lastAttempt.backoff) {
                    debugClient(`[attemptTrackRecovery] Skipping recovery for ${producerId}, last attempt was ${timeSinceLastAttempt}ms ago (backoff: ${lastAttempt.backoff}ms)`);
                    return;
                }
            }
            
            // Initialize or update recovery tracking
            if (!window._recoveryAttempts) window._recoveryAttempts = {};
            
            // Calculate backoff time - start at 5s, double each attempt, max 60s
            let backoff = 5000;
            if (window._recoveryAttempts[producerId]) {
                backoff = Math.min(window._recoveryAttempts[producerId].backoff * 2, 60000);
            }
            
            // Record this attempt
            window._recoveryAttempts[producerId] = {
                timestamp: Date.now(),
                backoff: backoff,
                attempts: (window._recoveryAttempts[producerId]?.attempts || 0) + 1
            };
            
            debugClient(`[attemptTrackRecovery] Attempting to recover producer: ${producerId} (attempt ${window._recoveryAttempts[producerId].attempts}, backoff: ${backoff}ms)`);
            log(`üîÑ Attempting to recover media stream... (${window._recoveryAttempts[producerId].attempts})`);
            
            try {
                // First try to get any existing consumer for this producer
                let consumerFound = false;
                
                if (recvTransport && recvTransport.handler && recvTransport.handler._consumers) {
                    // Try to find the consumer for this producer
                    const consumers = recvTransport.handler._consumers;
                    for (const consumerId in consumers) {
                        const consumer = consumers[consumerId];
                        if (consumer && consumer.producerId === producerId) {
                            consumerFound = true;
                            log(`üîç Found existing consumer for producer ${producerId}, attempting to restart...`);
                            
                            // Try resuming the consumer
                            try {
                                await protooRequest('resumeConsumer', { consumerId: consumer.id });
                                consumer.resume();
                                log(`‚ñ∂Ô∏è Resume request sent for consumer ${consumer.id}`);
                                
                                // Try to force media flow using aggressive resume
                                for (let i = 0; i < 3; i++) {
                                    try {
                                        await protooRequest('resumeConsumer', { consumerId: consumer.id });
                                        consumer.resume();
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    } catch (e) {
                                        debugClient(`[attemptTrackRecovery] Error in aggressive resume: ${e.message}`);
                                    }
                                }
                                log(`üîÑ Sent multiple resume signals to help re-establish media flow`);
                                
                                // If track exists, try reattaching it
                                if (consumer.track) {
                                    log(`üîÑ Reattaching track from consumer...`);
                                    attachTrackToVideo(consumer.track, producerId);
                                } else {
                                    log(`‚ö†Ô∏è Consumer has no track to reattach`);
                                }
                            } catch (e) {
                                debugClient(`[attemptTrackRecovery] Error resuming consumer: ${e.message}`);
                                consumerFound = false; // Mark as not found so we try recreating
                            }
                            break;
                        }
                    }
                }
            } catch (e) {
                debugClient(`[attemptTrackRecovery] Error during recovery: ${e.message}`);
                log(`‚ùå Recovery attempt failed: ${e.message}`);
            }
        }

        async function joinSFU(){
          // Prevent multiple simultaneous joinSFU calls
          if (joinSfuInProgress) {
            debugClient('joinSFU already in progress, ignoring duplicate call');
            return;
          }
          
          joinSfuInProgress = true;
          
          log('üìπ Attempting to join SFU...'); 
          console.log('üìπ requesting camera');
          try {
            // Add a global error tracking counter to detect persistent failures
            if (typeof window._sfu_errors === 'undefined') {
              window._sfu_errors = 0;
            }
            
            // Check if we've had too many errors and should try a fallback approach
            const MAX_SFU_ERRORS = 3;
            if (window._sfu_errors >= MAX_SFU_ERRORS) {
              log('‚ö†Ô∏è Too many SFU connection failures. Using simplified connection mode...');
              setupSimplifiedRtcMode();
              joinSfuInProgress = false;
              return;
            }
            
            // Properly clean up existing transports first to avoid stale handlers
            if (recvTransport) {
              debugClient('[joinSFU] Cleaning up existing receive transport');
              try {
                recvTransport.close();
              } catch (e) {
                debugClient(`[joinSFU] Error closing receive transport: ${e.message}`);
              }
              recvTransport = null;
            }
            
            if (sendTransport) {
              debugClient('[joinSFU] Cleaning up existing send transport');
              try {
                sendTransport.close();
              } catch (e) {
                debugClient(`[joinSFU] Error closing send transport: ${e.message}`);
              }
              sendTransport = null;
            }
            
            // Wait a moment to ensure cleanup is complete
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Request appropriate media - always request audio, video depends on wantsVideo flag
            log(wantsVideo ? 'üé• Requesting video & audio...' : 'üé§ Requesting audio only...');
            
            // Set video constraints based on browser to ensure codec compatibility
            const videoConstraints = wantsVideo ? {
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { max: 30 }
            } : false;
            
            try {
              localStream = await navigator.mediaDevices.getUserMedia({
                video: videoConstraints, 
                audio: true
              });
              localVideo.srcObject = localStream; // Show local audio/video regardless
              log('üé§ Got local media stream.');
              console.log('üé§ got local media stream, wantsVideo:', wantsVideo);
            } catch (mediaError) {
              console.error('Error getting media:', mediaError);
              log(`‚ö†Ô∏è Media access error: ${mediaError.message}. Will continue with limited functionality.`);
              
              // Create an empty stream to continue
              localStream = new MediaStream();
              
              // Try with just audio if video failed
              if (wantsVideo) {
                try {
                  const audioOnlyStream = await navigator.mediaDevices.getUserMedia({video: false, audio: true});
                  audioOnlyStream.getAudioTracks().forEach(track => {
                    localStream.addTrack(track);
                  });
                  log('üé§ Got audio-only stream as fallback.');
                } catch (audioError) {
                  console.error('Error getting audio:', audioError);
                  log(`‚ö†Ô∏è Audio access error: ${audioError.message}. Continuing without local media.`);
                }
              }
            }
            
            // Log network connectivity info
            log('üåê Checking network connectivity...');
            try {
              const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
              if (connection) {
                log(`üåê Network type: ${connection.type || 'unknown'}, downlink: ${connection.downlink || 'unknown'} Mbps`);
                log(`üåê Effective type: ${connection.effectiveType || 'unknown'}, RTT: ${connection.rtt || 'unknown'} ms`);
              }
            } catch (e) {
              console.error('Error getting network info:', e);
            }
            
            if (!window.mediasoupClient || !window.mediasoupClient.Device) { 
                const errorMsg = 'mediasoupClient or mediasoupClient.Device is not available on window.';
                console.error(errorMsg, window.mediasoupClient);
                log(`‚ùå ERROR: ${errorMsg}`);
                return;
            }
            
            // Always create a fresh device to avoid stale capabilities
            device = new window.mediasoupClient.Device();
            
            log('üöÄ Requesting Router RTP Capabilities...');
            const routerRtpCapabilities = await protooRequest('getRouterRtpCapabilities');
            console.log('üîß Received Router RTP Capabilities:', routerRtpCapabilities);
            log('üëç Got Router RTP Capabilities.');
            
            // Ensure VP8 codec priority to improve cross-browser compatibility
            const isEdge = /Edge/.test(navigator.userAgent) || /Edg/.test(navigator.userAgent);
            
            // Only modify codecs if we have access to their structure
            try {
              if (routerRtpCapabilities.codecs && Array.isArray(routerRtpCapabilities.codecs)) {
                // Find VP8 codec and move it to the front of the list for higher priority
                const vp8Index = routerRtpCapabilities.codecs.findIndex(c => c.mimeType.toLowerCase() === 'video/vp8');
                if (vp8Index > 0) {
                  debugClient(`[joinSFU] Moving VP8 codec from position ${vp8Index} to position 0 for better compatibility`);
                  const vp8Codec = routerRtpCapabilities.codecs.splice(vp8Index, 1)[0];
                  routerRtpCapabilities.codecs.unshift(vp8Codec);
                  log('üîß Prioritized VP8 codec for better browser compatibility');
                }
                
                // If browser is Edge, specifically force H264 profile level to a widely supported one
                if (isEdge && wantsVideo) {
                  routerRtpCapabilities.codecs.forEach(codec => {
                    if (codec.mimeType.toLowerCase() === 'video/h264') {
                      // Ensure baseline profile for maximum compatibility
                      codec.parameters = codec.parameters || {};
                      codec.parameters['profile-level-id'] = '42e01f';
                      codec.parameters['level-asymmetry-allowed'] = 1;
                      codec.parameters['packetization-mode'] = 1;
                      debugClient(`[joinSFU] Modified H264 codec parameters for Edge compatibility`);
                    }
                  });
                }
              }
            } catch (e) {
              debugClient(`[joinSFU] Error modifying codecs: ${e.message}`);
            }
            
            await device.load({ routerRtpCapabilities });
            console.log('üîß Device loaded with router capabilities');
            log('üëç Device loaded.');
            
            // Use TCP-optimized transport for all browsers to improve firewall traversal
            log('üîç Using TCP-optimized transport settings for firewall compatibility');
            
            const transportOptions = {
              additionalIceServers: [
                {
                  urls: 'turn:global.turn.twilio.com:443?transport=tcp',
                  username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                  credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                },
                {
                  urls: 'turns:global.turn.twilio.com:443?transport=tcp',
                  username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                  credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
                }
              ],
              // For Edge browser, force relay mode
              ...((/Edge/.test(navigator.userAgent)) ? {
                iceTransportPolicy: 'relay'
              } : {})
            };
            
            // Create both transports with optimized settings
            log('üöö Creating TCP-optimized send transport...');
            sendTransport = await makeTransport('send', transportOptions);
            console.log('üöö send transport ready', sendTransport.id);
            log(`üëç TCP-optimized send transport created: ${sendTransport.id}`);
            
            log('üì• Creating TCP-optimized recv transport...');
            recvTransport = await makeTransport('recv', transportOptions);
            console.log('üì• recv transport ready', recvTransport.id);
            log(`üëç TCP-optimized recv transport created: ${recvTransport.id}`);
            
            // Store transport IDs for verification
            storeTransportIds(sendTransport.id, recvTransport.id);
            
            // Now that transports (especially recvTransport) are ready, process pending consumers
            await processPendingConsumers();

            // Then produce local media if we have tracks to send
            if (wantsVideo && localStream) {
              const camTrack = localStream.getVideoTracks()[0];
              if (camTrack) {
                log('üì° Producing video track...');
                await sendTransport.produce({ track: camTrack, appData: { source: 'webcam' } }); 
                console.log('üì° produced local video');
                log('üì° Video produced.');
              } else {
                log('‚ÑπÔ∏è No video track available to produce.');
              }
            } else {
              log(wantsVideo ? '‚ö†Ô∏è No local stream available for video.' : 'üîá Video production disabled by ?novideo flag.');
            }
            
            // Always produce audio if available
            if (localStream) {
              const audioTrack = localStream.getAudioTracks()[0];
              if (audioTrack) {
                log('üé§ Producing audio track...');
                await sendTransport.produce({ track: audioTrack, appData: { source: 'microphone' } });
                log('üé§ Audio produced.');
              } else {
                log('‚ÑπÔ∏è No audio track available to produce.');
              }
            }
            
            log('üéß Listening for new producers (via global handler)...');
            aiGreeting();

            startWebRTCStats();

          } catch (err) {
            console.error('Error in joinSFU:', err);
            log(`‚ùå ERROR in joinSFU: ${err.message}`);
            
            // Track errors for fallback system
            window._sfu_errors = (window._sfu_errors || 0) + 1;
            console.warn(`SFU connection error count: ${window._sfu_errors}/${MAX_SFU_ERRORS}`);
            
            // If too many errors have occurred, switch to simplified mode on next attempt
            if (window._sfu_errors >= MAX_SFU_ERRORS) {
              log(`‚ö†Ô∏è Multiple SFU connection failures detected.`);
              log(`üîÑ Next attempt will use simplified connection mode.`);
            }
          } finally {
            // Reset the join progress flag
            joinSfuInProgress = false;
          }
        }
        
        // AI greeting after media & SFU ready (or at least initiated)
        async function aiGreeting(){
          const greetingPrompt = `Say: Hello ${userName}. Welcome to the session! How are things going with Ultra so far?`;
          const res = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message: greetingPrompt, userId:'<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: '+data.reply);
          // await logMessage('ai', data.reply); // logMessage might not be defined here.
          // playTTS(data.reply); // playTTS might not be defined here.
        }

        // Chat with AI (ensure logMessage and playTTS are available or remove)
        const inputEl = document.getElementById('msgInput');
        document.getElementById('sendBtn').onclick = async () => {
          const text = inputEl.value.trim();
          if(!text) return;
          log('You: ' + text);
          inputEl.value='';
          // await logMessage('client', text);
          const res  = await fetch('/api/chat', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ message: text, userId: '<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: ' + data.reply);
          // await logMessage('ai', data.reply);
          // playTTS(data.reply);
        };

        // Call timer & 15-minute callback
        const timerEl = document.getElementById('callTimer');
        let originTs = null;
        socket.on('room-start', ts => { originTs = ts; });

        let fifteenFired = false;
        setInterval(async () => {
          if(originTs === null) return;
          const elapsed = Math.floor((Date.now() - originTs)/1000);
          const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
          const ss = String(elapsed%60).padStart(2,'0');
          timerEl.textContent = `${mm}:${ss}`;

          if (!fifteenFired && elapsed >= 900){ // 15 minutes = 900 seconds
            fifteenFired = true;
            const note = 'System: The coach has another call in 5 minutes and will step away soon. Please provide any final recommendations for the next week of Ultra use.';
            // await logMessage('system', note);
            const res = await fetch('/api/chat', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ message: note, userId:'<%= user.id %>', sessionId }) });
            const data = await res.json();
            log('AI: '+data.reply);
            // await logMessage('ai', data.reply);
            // playTTS(data.reply);
          }
        },1000);
        
        // Start media connection monitoring to keep ICE alive
        function monitorMediaConnection() {
          // Data channel keepalive - critical for preventing NAT timeouts
          let keepaliveInterval = null;
          
          // Track data channels to prevent duplicates
          if (!window._dataChannels) window._dataChannels = new Map();
          
          // Start data channel keepalive for both transports with higher frequency
          if (recvTransport && recvTransport.connectionState === 'connected') {
            const recvChannel = createKeepaliveDataChannel(recvTransport, 'recv-keepalive');
            if (recvChannel) {
              debugClient('[monitorMedia] Created keepalive data channel for recv transport');
            }
          }
          
          if (sendTransport && sendTransport.connectionState === 'connected') {
            const sendChannel = createKeepaliveDataChannel(sendTransport, 'send-keepalive');
            if (sendChannel) {
              debugClient('[monitorMedia] Created keepalive data channel for send transport');
            }
          }
          
          function createKeepaliveDataChannel(transport, label) {
            if (!transport || !transport.handler || !transport.handler._pc) {
              return null;
            }
            
            // Check if we already have a channel for this transport
            if (window._dataChannels.has(transport.id)) {
              const existingChannel = window._dataChannels.get(transport.id);
              if (existingChannel && existingChannel.readyState === 'open') {
                debugClient(`[iceKeepalive] Using existing channel for ${transport.id}`);
                return existingChannel;
              }
            }
            
            const pc = transport.handler._pc;
            
            try {
              // Create a data channel specifically for keepalive
              const channel = pc.createDataChannel(label, {
                ordered: true,
                protocol: 'keepalive'
              });
              
              // Store the channel for future reference
              window._dataChannels.set(transport.id, channel);
              
              channel.onopen = () => {
                debugClient(`[iceKeepalive] Channel '${label}' open for ${transport.id}`);
                
                // Send small packets every 5 seconds to maintain NAT bindings
                // More frequent for better NAT hole punching
                if (keepaliveInterval) {
                  clearInterval(keepaliveInterval);
                }
                
                keepaliveInterval = setInterval(() => {
                  if (channel.readyState === 'open') {
                    try {
                      // Send a small packet with timestamp to keep the connection alive
                      channel.send(JSON.stringify({ 
                        type: 'keepalive', 
                        ts: Date.now(),
                        id: Math.random().toString(36).substring(2,9)  // Random ID to prevent caching
                      }));
                      debugClient(`[iceKeepalive] Sent keepalive on ${label}`);
                    } catch (e) {
                      debugClient(`[iceKeepalive] Error sending keepalive: ${e.message}`);
                    }
                  } else {
                    // Try to recreate channel if it's closed
                    debugClient(`[iceKeepalive] Channel state is ${channel.readyState}, recreating`);
                    clearInterval(keepaliveInterval);
                    setTimeout(() => {
                      createKeepaliveDataChannel(transport, label);
                    }, 1000);
                  }
                }, 5000); // More frequent keepalive for better NAT traversal
              };
              
              channel.onclose = () => {
                debugClient(`[iceKeepalive] Channel '${label}' closed for ${transport.id}`);
                clearInterval(keepaliveInterval);
                
                // Try to recreate after a short delay
                setTimeout(() => {
                  createKeepaliveDataChannel(transport, label);
                }, 2000);
              };
              
              channel.onerror = (err) => {
                debugClient(`[iceKeepalive] Channel '${label}' error: ${err}`);
                clearInterval(keepaliveInterval);
              };
              
              return channel;
            } catch (e) {
              debugClient(`[iceKeepalive] Error creating channel: ${e.message}`);
              return null;
            }
          }
          
          // Setup ICE connection monitoring with recovery
          setupIceConnectionMonitoring();
          
          function setupIceConnectionMonitoring() {
            // Monitor both transports for connection issues
            monitorTransportIce(recvTransport, 'recv');
            monitorTransportIce(sendTransport, 'send');
            
            function monitorTransportIce(transport, type) {
              if (!transport || !transport.handler || !transport.handler._pc) return;
              
              const pc = transport.handler._pc;
              const transportId = transport.id;
              
              // Track last known good state
              let lastGoodState = Date.now();
              let recoveryAttempted = false;
              
              // Check connection every 5 seconds
              const monitor = setInterval(() => {
                const connState = pc.iceConnectionState;
                
                if (connState === 'connected' || connState === 'completed') {
                  // Connection is good, reset recovery flags
                  lastGoodState = Date.now();
                  recoveryAttempted = false;
                  debugClient(`[iceMonitor] ${type} transport ${transportId} has good connection: ${connState}`);
                } 
                else if (['disconnected', 'failed', 'closed'].includes(connState)) {
                  // Connection is bad, check how long it's been this way
                  const disconnectedTime = (Date.now() - lastGoodState) / 1000;
                  
                  if (disconnectedTime > 10 && !recoveryAttempted) {
                    // After 10 seconds of bad connection, try recovery
                    log(`üõ†Ô∏è ${type} transport has ${connState} ICE connection for ${Math.round(disconnectedTime)}s. Attempting recovery...`);
                    recoveryAttempted = true;
                    
                    // Try ICE restart first - gentle recovery
                    try {
                      debugClient(`[iceMonitor] Attempting ICE restart for ${type} transport ${transportId}`);
                      pc.restartIce();
                      
                      // If that doesn't work after 8 seconds, try more aggressive recovery
                      setTimeout(() => {
                        if (['disconnected', 'failed', 'closed'].includes(pc.iceConnectionState)) {
                          debugClient(`[iceMonitor] ICE restart didn't fix ${type} transport, trying transport recreation`);
                          log(`üîÑ ICE restart insufficient, recreating ${type} transport...`);
                          
                          // More aggressive recovery - recreate the transport
                          if (typeof refreshTransport === 'function') {
                            refreshTransport(type);
                          }
                        }
                      }, 8000);
                    } catch (e) {
                      debugClient(`[iceMonitor] Error during ICE restart: ${e.message}`);
                      log(`‚ùå ICE restart failed: ${e.message}`);
                      
                      // Immediate aggressive recovery on restart failure
                      if (typeof refreshTransport === 'function') {
                        refreshTransport(type);
                      }
                    }
                  }
                }
              }, 5000);
              
              // Clean up monitor when transport is closed
              transport.on('close', () => {
                clearInterval(monitor);
                debugClient(`[iceMonitor] Cleared monitor for ${type} transport ${transportId}`);
              });
            }
          }
          
          // Check for full connection failure
          let fullConnectionChecks = 0;
          const MAX_FULL_CHECKS = 5;
          
          function checkFullConnectionHealth() {
            // If both transports have failed, try a complete restart
            if ((!recvTransport || recvTransport.connectionState === 'failed' || recvTransport.connectionState === 'closed') &&
                (!sendTransport || sendTransport.connectionState === 'failed' || sendTransport.connectionState === 'closed')) {
              
              fullConnectionChecks++;
              
              if (fullConnectionChecks <= MAX_FULL_CHECKS) {
                log(`‚ö†Ô∏è Complete media connection failure detected. Attempting full reconnect (${fullConnectionChecks}/${MAX_FULL_CHECKS})...`);
                
                // Clean up existing transports
                if (recvTransport) {
                  try { recvTransport.close(); } catch (e) {}
                  recvTransport = null;
                }
                
                if (sendTransport) {
                  try { sendTransport.close(); } catch (e) {}
                  sendTransport = null;
                }
                
                // Try to rejoin SFU
                setTimeout(() => {
                  joinSFU();
                }, 2000);
              } else {
                log(`‚ùå Maximum reconnection attempts (${MAX_FULL_CHECKS}) reached. Please refresh the page.`);
              }
            } else {
              // Reset counter when at least one transport is working
              fullConnectionChecks = 0;
            }
            
            // Continue checking every 30 seconds
            setTimeout(checkFullConnectionHealth, 30000);
          }
          
          // Start full connection health check
          setTimeout(checkFullConnectionHealth, 30000);
        }

        // Helper to store and verify transport IDs
        function storeTransportIds(sendId, recvId) {
          window._transportIds = {
            send: sendId,
            recv: recvId,
            timestamp: Date.now()
          };
          
          // Save to localStorage for recovery across page loads
          try {
            localStorage.setItem('mediasoup_transport_ids', JSON.stringify(window._transportIds));
          } catch (e) {
            console.error('Error saving transport IDs to localStorage:', e);
          }
        }

        // Helper to check if a transport ID is still valid
        function isTransportValid(type, id) {
          if (!window._transportIds) return false;
          
          // Check if transport ID matches what we stored
          const isValid = window._transportIds[type] === id;
          
          // Check if it's not too old (> 1 hour = invalid)
          const isNotTooOld = (Date.now() - window._transportIds.timestamp) < (60 * 60 * 1000);
          
          return isValid && isNotTooOld;
        }

        // Function to refresh a specific transport without full reconnection
        let refreshTransport = async function(direction, forceTurn = false) {
          debugClient(`[refreshTransport] Called for ${direction}, forceTurn=${forceTurn}`);
          
          try {
            // Close the old transport
            if (direction === 'recv' && recvTransport) {
              try {
                recvTransport.close();
              } catch (e) {
                debugClient(`[refreshTransport] Error closing receive transport: ${e.message}`);
              }
              recvTransport = null;
            } else if (direction === 'send' && sendTransport) {
              try {
                sendTransport.close();
              } catch (e) {
                debugClient(`[refreshTransport] Error closing send transport: ${e.message}`);
              }
              sendTransport = null;
            }
            
            // Configure better TURN servers with TCP fallbacks
            const turnServers = [
              // TCP TURN servers are more reliable through firewalls
              {
                urls: 'turn:global.turn.twilio.com:443?transport=tcp',
                username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
              },
              {
                urls: 'turns:global.turn.twilio.com:443?transport=tcp',
                username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
              }
            ];
            
            // Always force TURN relay mode in reconnection attempts
            const transportOptions = {
              additionalIceServers: turnServers,
              // Force relay mode for reconnection attempts for more reliability
              iceTransportPolicy: 'relay',
              iceTcpPolicy: 'prefer'
            };
            
            // If this is a retry after failure, force TCP-only TURN
            if (forceTurn) {
              log('üîÑ Using TCP-only TURN for guaranteed firewall traversal');
              transportOptions.iceTcpMux = true; // Enable TCP multiplexing if available
            }
            
            if (direction === 'recv') {
              log('üì• Creating new receive transport...');
              recvTransport = await makeTransport('recv', transportOptions);
              
              // Update stored ID
              storeTransportIds(
                window._transportIds && window._transportIds.send ? window._transportIds.send : null,
                recvTransport.id
              );
              
              log(`üëç New receive transport created: ${recvTransport.id}`);
              
              // Re-consume existing producers
              setTimeout(() => processPendingConsumers(), 500);
            } else if (direction === 'send') {
              log('üöö Creating new send transport...');
              sendTransport = await makeTransport('send', transportOptions);
              
              // Update stored ID
              storeTransportIds(
                sendTransport.id,
                window._transportIds && window._transportIds.recv ? window._transportIds.recv : null
              );
              
              log(`üëç New send transport created: ${sendTransport.id}`);
              
              // Re-produce local media if needed
              if (wantsVideo && localStream) {
                const camTrack = localStream.getVideoTracks()[0];
                if (camTrack) {
                  log('üì° Re-producing video track...');
                  await sendTransport.produce({ track: camTrack, appData: { source: 'webcam' } });
                  log('üì° Video re-produced.');
                }
              }
              
              // Always re-produce audio if available
              if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                  log('üé§ Re-producing audio track...');
                  await sendTransport.produce({ track: audioTrack, appData: { source: 'microphone' } });
                  log('üé§ Audio re-produced.');
                }
              }
            }
          } catch (err) {
            debugClient(`[refreshTransport] Error refreshing ${direction} transport:`, err);
            log(`‚ùå Failed to refresh ${direction} transport: ${err.message}`);
          }
        };

        // WebSocket fallback mode for environments where WebRTC is completely blocked
        function setupWebSocketFallback() {
          // Clean up any existing WebRTC resources
          if (recvTransport) {
            try { recvTransport.close(); } catch(e) {}
            recvTransport = null;
          }
          
          if (sendTransport) {
            try { sendTransport.close(); } catch(e) {}
            sendTransport = null;
          }
          
          // Set up WebSocket relay mode
          log('üîÑ Setting up WebSocket relay mode...');
          
          if (!window._wsRelay) {
            // Create WebSocket connection for relaying media frames
            const wsUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}/ws-relay`;
            const wsRelay = new WebSocket(wsUrl);
            
            wsRelay.onopen = () => {
              log('‚úÖ WebSocket relay connected');
              
              // Send join message with room info
              wsRelay.send(JSON.stringify({
                type: 'join',
                roomId,
                peerId: peerId,
                userRole: userRole
              }));
              
              // Set up local video snapshot sending
              if (localVideo && localVideo.srcObject) {
                setupVideoFrameSending(wsRelay);
              }
              
              // Set up relay mode for receiving
              setupWebSocketReceiving(wsRelay);
            };
            
            wsRelay.onclose = () => {
              log('üî¥ WebSocket relay disconnected');
              // Try to reconnect after a delay
              setTimeout(() => {
                log('üîÑ Attempting to reconnect WebSocket relay...');
                setupWebSocketFallback();
              }, 3000);
            };
            
            wsRelay.onerror = (err) => {
              log(`‚ùå WebSocket relay error: ${err.message || 'Unknown error'}`);
            };
            
            window._wsRelay = wsRelay;
          }
        }
        
        // Function to send local video frames via WebSocket relay
        function setupVideoFrameSending(wsRelay) {
          const canvas = document.createElement('canvas');
          canvas.width = 320;  // Reduced size for WebSocket efficiency
          canvas.height = 240;
          const ctx = canvas.getContext('2d');
          
          log('üì° Starting WebSocket video relay...');
          
          // Capture and send frames at a reduced rate (3fps)
          const sendInterval = setInterval(() => {
            if (!wsRelay || wsRelay.readyState !== WebSocket.OPEN) {
              clearInterval(sendInterval);
              return;
            }
            
            try {
              // Draw video frame to canvas at reduced size
              ctx.drawImage(localVideo, 0, 0, 320, 240);
              
              // Convert to JPEG and send
              canvas.toBlob((blob) => {
                if (blob && wsRelay.readyState === WebSocket.OPEN) {
                  // Create a reader to convert blob to base64
                  const reader = new FileReader();
                  reader.onloadend = () => {
                    const base64data = reader.result.split(',')[1];
                    wsRelay.send(JSON.stringify({
                      type: 'videoFrame',
                      data: base64data,
                      roomId: roomId,
                      peerId: peerId
                    }));
                  };
                  reader.readAsDataURL(blob);
                }
              }, 'image/jpeg', 0.5);  // 50% quality for bandwidth efficiency
            } catch (e) {
              console.error('Error sending frame:', e);
            }
          }, 333);  // ~3fps
        }
        
        // Function to receive and display video frames via WebSocket relay
        function setupWebSocketReceiving(wsRelay) {
          if (!remoteVideo) return;
          
          // Create a canvas for rendering received frames
          const canvas = document.createElement('canvas');
          canvas.width = 320;
          canvas.height = 240;
          
          // Replace video element with canvas
          remoteVideo.style.display = 'none';
          canvas.style.border = remoteVideo.style.border;
          canvas.style.margin = remoteVideo.style.margin;
          canvas.style.width = remoteVideo.style.width;
          remoteVideo.parentNode.insertBefore(canvas, remoteVideo);
          
          const ctx = canvas.getContext('2d');
          
          // Handle incoming WebSocket messages
          wsRelay.onmessage = (event) => {
            try {
              const msg = JSON.parse(event.data);
              
              if (msg.type === 'videoFrame') {
                // Someone else's video frame
                if (msg.peerId !== peerId) {
                  // Convert base64 to image
                  const img = new Image();
                  img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                  };
                  img.src = `data:image/jpeg;base64,${msg.data}`;
                }
              }
              else if (msg.type === 'chat') {
                // Chat messages
                if (msg.peerId !== peerId) {
                  log(`AI: ${msg.text}`);
                }
              }
            } catch (e) {
              console.error('Error processing WebSocket message:', e);
            }
          };
        }

        // Simplified peer connection mode as fallback when SFU fails repeatedly
        function setupSimplifiedRtcMode() {
          log('üîÑ Setting up simplified peer-to-peer mode...');
          
          // When we switch to simplified mode, we'll use direct WebRTC connections
          const simplePeerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              {
                urls: 'turn:global.turn.twilio.com:3478?transport=tcp',
                username: 'f4b4035eaa76f77e3423b4d0982bda7854d311ec95e6f4b0ad0f641259f0f000',
                credential: 'w1WpuQdnuKlG/JP2n7RdO+fBB6wE0gVBZ/kBPjLmrG8='
              }
            ],
            sdpSemantics: 'unified-plan',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            iceTransportPolicy: 'all'
          });
          
          log('üì≤ Created simplified peer connection');
          
          // Add event listeners for connection state changes
          simplePeerConnection.addEventListener('iceconnectionstatechange', () => {
            log(`üßä ICE connection state: ${simplePeerConnection.iceConnectionState}`);
          });
          
          // Get local media (only audio for simplified mode)
          if (!localStream) {
            log('üé§ Requesting audio for simplified mode...');
            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
              .then(stream => {
                localStream = stream;
                localVideo.srcObject = stream;
                log('üé§ Got local audio stream for simplified mode');
                
                // Add local tracks to the connection
                stream.getTracks().forEach(track => {
                  simplePeerConnection.addTrack(track, stream);
                  log(`‚ûï Added ${track.kind} track to simplified connection`);
                });
                
                // Create and send offer
                simplePeerConnection.createOffer()
                  .then(offer => {
                    log('üì§ Created offer for simplified mode');
                    return simplePeerConnection.setLocalDescription(offer);
                  })
                  .then(() => {
                    log('üìù Set local description for simplified connection');
                    
                    // Send offer through socket.io instead of protoo
                    socket.emit('signal', {
                      target: 'server', 
                      signal: { 
                        type: 'offer',
                        sdp: simplePeerConnection.localDescription
                      }
                    });
                    log('üì° Sent offer through socket.io');
                  })
                  .catch(err => {
                    console.error('Error setting up simplified offer:', err);
                    log(`‚ùå Error in simplified offer: ${err.message}`);
                  });
              })
              .catch(err => {
                console.error('Error getting media for simplified mode:', err);
                log(`‚ùå Media error in simplified mode: ${err.message}`);
              });
          }
          
          // Handle ICE candidates
          simplePeerConnection.onicecandidate = event => {
            if (event.candidate) {
              socket.emit('signal', {
                target: 'server',
                signal: {
                  type: 'candidate',
                  candidate: event.candidate
                }
              });
            }
          };
          
          // Handle incoming tracks
          simplePeerConnection.ontrack = event => {
            log(`üì• Received ${event.track.kind} track in simplified mode`);
            if (remoteVideo.srcObject) {
              remoteVideo.srcObject.addTrack(event.track);
            } else {
              remoteVideo.srcObject = new MediaStream([event.track]);
            }
            log('‚ñ∂Ô∏è Playing remote media in simplified mode');
          };
          
          // Listen for answer and candidates from server
          socket.on('signal', data => {
            if (data.signal.type === 'answer') {
              log('üì© Received answer in simplified mode');
              const answer = new RTCSessionDescription(data.signal);
              simplePeerConnection.setRemoteDescription(answer)
                .then(() => {
                  log('üìù Set remote description from answer');
                })
                .catch(err => {
                  console.error('Error setting remote description:', err);
                  log(`‚ùå Error with remote description: ${err.message}`);
                });
            } else if (data.signal.type === 'candidate') {
              log('üßä Received ICE candidate in simplified mode');
              simplePeerConnection.addIceCandidate(new RTCIceCandidate(data.signal.candidate))
                .catch(err => {
                  console.error('Error adding ICE candidate:', err);
                  log(`‚ùå Error adding ICE candidate: ${err.message}`);
                });
            }
          });
          
          log('üîå Simplified peer connection mode ready');
        }
      }); // End of waitForDependencies callback
    </script>
  </body>
</html> 