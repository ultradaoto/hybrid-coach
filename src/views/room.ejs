<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= title %></title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #f9fafb;
        flex-direction: column;
      }
      #videoContainer{ display:flex; }
      #videoContainer.reverse{ flex-direction:row-reverse; }
      video {
        width: 45%;
        max-width: 480px;
        border: 2px solid #2d3748;
        margin: 0.5rem;
      }
      #messages { height:120px; overflow:auto; width:90%; margin-top:1rem; background:#fff; padding:0.5rem; border:1px solid #ccc; }
    </style>
  </head>
  <body>
    <h2>Hybrid Coaching Call</h2>
    <div id="videoContainer">
      <video id="localVideo" autoplay playsinline muted></video>
      <video id="remoteVideo" autoplay playsinline></video>
      <div style="display:flex; width:100%; justify-content:center;">
        <span id="localLabel" style="width:45%; text-align:center;"></span>
        <span id="remoteLabel" style="width:45%; text-align:center;"></span>
      </div>
    </div>
    <div id="messages"></div>
    <div style="margin-top:0.5rem; width:90%; display:flex;">
      <input id="msgInput" style="flex:1; padding:0.5rem" placeholder="Type a message to Hybrid AI..." />
      <button id="sendBtn">Send</button>
    </div>
    <div style="margin-top:0.5rem; font-weight:bold;" id="callTimer">00:00</div>

    <script src="/socket.io/socket.io.js"></script>

    <!-- Load mediasoup-client and protoo-client as ES modules -->
    <script type="module">
      import mediasoupClientModule from 'https://esm.sh/mediasoup-client@3.11.0';
      import protooClientModule from 'https://esm.sh/protoo-client@4.0.4';
      
      window.mediasoupClient = mediasoupClientModule; // Expose the whole module
      window.protooClient = protooClientModule;
      
      console.log('mediasoup-client and protoo-client modules script has run.');
      // Consider a custom event here if waitForDependencies needs a more robust signal
    </script>

    <!-- Main application logic script -->
    <script>
      // Wait for dependencies to load (now set by the module script)
      function waitForDependencies(callback) {
        const messagesDiv = document.getElementById('messages'); // Get messages div for logging
        function persistentLog(msg) { // Helper to log to console and page
            console.log(msg);
            if(messagesDiv) messagesDiv.innerHTML += msg + '<br>';
        }

        persistentLog('Initializing: Waiting for client libraries...');
        const checkInterval = setInterval(() => {
          const msClientReady = !!window.mediasoupClient;
          const ptClientReady = !!window.protooClient;

          if (msClientReady && ptClientReady) {
            clearInterval(checkInterval);
            persistentLog('‚úÖ All client libraries (mediasoupClient, protooClient) are loaded.');
            callback();
          } else {
            persistentLog('‚è≥ Waiting... mediasoupClient: ' + (msClientReady ? 'OK' : 'MISSING') + ', protooClient: ' + (ptClientReady ? 'OK' : 'MISSING'));
          }
        }, 200); // Check every 200ms for visibility
      }

      waitForDependencies(() => {
        // Main app logic will now use window.mediasoupClient.Device etc.
        // ... (rest of the main script) ...
        const roomId = "<%= roomId %>";
        const userRole = "<%= user.role %>";
        const userName = "<%= user.displayName || user.email %>";
        const jwtToken = "<%= jwt %>";
        const sessionId = "<%= sessionId %>";
        localStorage.setItem('jwt', jwtToken);
        const socket = io(window.location.origin, {
          path: '/socket.io/',
          transports: ['websocket', 'polling'], // Try websocket first, fall back to polling
          reconnectionAttempts: 5,
          reconnectionDelay: 1000,
          timeout: 20000 // Increase timeout
        });
        const messages = document.getElementById('messages');

        const peerId = `pid_${Math.random().toString(36).substr(2, 9)}`;
        let protooPeer;
        let localStream;
        let sendTransport, recvTransport, device;
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        
        const wantsVideo = !window.location.search.includes('novideo');
        const stunServers = [ // Public STUN servers with fallbacks
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' },
          // Additional STUN servers as fallback
          { urls: 'stun:stun.ekiga.net' },
          { urls: 'stun:stun.ideasip.com' },
          { urls: 'stun:stun.schlund.de' }
        ];
        debugClient(`Client wantsVideo: ${wantsVideo}`);

        let pendingProducersToConsume = [];

        function log(msg){ messages.innerHTML += msg + '<br>'; }
        function debugClient(message) { console.log('[CLIENT DEBUG]', message); }

        socket.emit('join-room', { roomId, name: userName });

        document.getElementById('localLabel').innerText = userName + ' (You)';
        if(userRole === 'coach'){
          document.getElementById('videoContainer').classList.add('reverse');
        }

        const protooWebSocketUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}/protoo?roomId=${roomId}&peerId=${peerId}`;
        const transport = new window.protooClient.WebSocketTransport(protooWebSocketUrl);
        protooPeer = new window.protooClient.Peer(transport);

        protooPeer.on('open', () => {
          console.log('Protoo connection open. Calling joinSFU(). PeerID:', peerId, 'RoomID:', roomId);
          log('‚úÖ Protoo connection established.');
          joinSFU(); 
        });

        protooPeer.on('request', (request, accept, reject) => {
          console.log('Received Protoo request from server (unexpected on client):', request);
          reject(501, 'Client does not handle requests'); 
        });

        // Generic notification handler - primarily for newProducers
        protooPeer.on('notification', async (notification) => {
          debugClient(`Received Protoo notification: ${notification.method}`);
          if (notification.method === 'newProducer') {
            const producerInfo = notification.data;
            if (device && device.loaded) {
              debugClient('Device is loaded, consuming producer immediately:', producerInfo.producerId);
              await consumeProducer(producerInfo);
            } else {
              debugClient('Device not loaded yet, queueing producer:', producerInfo.producerId);
              pendingProducersToConsume.push(producerInfo);
              log('‚ö†Ô∏è Device not loaded, producer queued: ' + producerInfo.producerId);
            }
          }
        });

        protooPeer.on('failed', (currentAttempt, maxAttempts) => {
          console.error(`Protoo connection attempt ${currentAttempt} of ${maxAttempts} failed. URL: ${protooWebSocketUrl}`);
          log(`üî¥ Protoo connection failed (attempt ${currentAttempt}/${maxAttempts}). Will not auto-retry.`);
        });

        protooPeer.on('disconnected', () => {
          console.error('Protoo disconnected. URL:', protooWebSocketUrl);
          log('üî¥ Protoo disconnected.');
        });

        protooPeer.on('close', () => {
          console.log('Protoo connection closed. URL:', protooWebSocketUrl);
          log('‚ÑπÔ∏è Protoo connection closed.');
        });

        function protooRequest(method, data = {}) {
          if (!protooPeer || !protooPeer.connected) {
            const errorMsg = `Protoo peer not connected. Cannot send request: ${method}`;
            console.error(errorMsg, 'Peer state:', protooPeer ? protooPeer.state : 'undefined');
            log(`üî¥ ${errorMsg}`);
            return Promise.reject(new Error(errorMsg));
          }
          return protooPeer.request(method, data);
        }

        function startWebRTCStats() {
          if (!recvTransport || !sendTransport) {
            debugClient('[startWebRTCStats] Transports not ready, will retry in 5s');
            setTimeout(startWebRTCStats, 5000);
            return;
          }

          // Give more time for connection to establish - wait 10 seconds before first check
          setTimeout(() => {
            // Check stats every 5 seconds
            const statsInterval = setInterval(async () => {
              try {
                if (!recvTransport || !sendTransport) {
                  debugClient('[webrtcStats] Transports closed, stopping stats interval');
                  clearInterval(statsInterval);
                  return;
                }

                // Log the connection state
                const recvState = recvTransport.connectionState;
                const sendState = sendTransport.connectionState;
                debugClient(`[webrtcStats] Transport states - recv: ${recvState}, send: ${sendState}`);
                
                if (recvState === 'connected' && sendState === 'connected') {
                  log(`‚úÖ WebRTC connection established successfully!`);
                  // Once connected, we can reduce frequency of checks
                  clearInterval(statsInterval);
                  // Keep checking less frequently
                  setInterval(() => {
                    const rs = recvTransport.connectionState;
                    const ss = sendTransport.connectionState;
                    if (rs !== 'connected' || ss !== 'connected') {
                      log(`‚ö†Ô∏è WebRTC connection changed: recv=${rs}, send=${ss}`);
                    }
                  }, 10000);
                } else if (recvState !== 'connected' || sendState !== 'connected') {
                  log(`üìä Transport states: recv=${recvState}, send=${sendState}`);
                }

                // For WebRTC internals debugging
                if (recvTransport.handler && recvTransport.handler._pc) {
                  const pc = recvTransport.handler._pc;
                  const stats = await pc.getStats();
                  let hasActiveCandidate = false;
                  let candidatePairs = [];

                  stats.forEach(stat => {
                    if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {
                      hasActiveCandidate = true;
                      candidatePairs.push(`${stat.localCandidateId} <-> ${stat.remoteCandidateId} (${stat.state})`);
                    }
                  });

                  if (!hasActiveCandidate && (recvState !== 'connected' || sendState !== 'connected')) {
                    debugClient('[webrtcStats] No active candidate pairs found. This indicates NAT traversal issues.');
                    log('‚ö†Ô∏è NAT traversal issue detected. Check firewall settings.');
                  } else if (hasActiveCandidate) {
                    debugClient(`[webrtcStats] Active candidate pairs: ${candidatePairs.join(', ')}`);
                    log('üîÑ ICE candidate pairs established successfully.');
                  }
                }
              } catch (e) {
                debugClient('[webrtcStats] Error collecting stats:', e);
              }
            }, 5000);
          }, 10000); // Initial 10 second wait
        }

        async function makeTransport(direction) {
          try {
            debugClient(`[makeTransport] Requesting server to create ${direction} transport...`);
            
            // Get TURN credentials from server
            let iceServersToUse = stunServers;
            try {
              const turnResponse = await fetch('/api/turn-credentials');
              if (turnResponse.ok) {
                const turnData = await turnResponse.json();
                if (turnData.iceServers && turnData.iceServers.length > 0) {
                  // Enhanced logging of ice servers
                  debugClient(`[makeTransport] Raw Twilio ICE servers response: ${JSON.stringify(turnData.iceServers)}`);
                  
                  // Log details of each ICE server
                  turnData.iceServers.forEach((server, idx) => {
                    const urls = Array.isArray(server.urls) ? server.urls.join(', ') : server.urls;
                    debugClient(`[makeTransport] ICE Server ${idx + 1}: ${urls}`);
                    if (server.credential) {
                      // Don't log actual credentials for security
                      debugClient(`[makeTransport] Server ${idx + 1} has credentials: YES (redacted)`);
                    }
                    // Log if it's a TURN server
                    if (urls && urls.includes('turn:')) {
                      debugClient(`[makeTransport] Server ${idx + 1} is a TURN server`);
                    }
                  });
                  
                  iceServersToUse = turnData.iceServers;
                  debugClient(`[makeTransport] Successfully fetched Twilio ICE servers: ${iceServersToUse.length} servers`);
                  log(`üåê Using Twilio TURN/STUN servers`);
                } else {
                  debugClient('[makeTransport] No ICE servers returned from Twilio, using fallback STUN servers');
                  log(`‚ö†Ô∏è Using fallback STUN servers only`);
                }
              } else {
                debugClient('[makeTransport] Failed to fetch TURN credentials, using fallback STUN servers');
                log(`‚ö†Ô∏è Using fallback STUN servers only`);
              }
            } catch (e) {
              debugClient('[makeTransport] Error fetching TURN credentials:', e);
              log(`‚ö†Ô∏è Using fallback STUN servers only`);
            }
            
            const serverResponse = await protooRequest('createWebRtcTransport', {
              producing: direction === 'send',
              consuming: direction === 'recv',
              // Include SCTP capabilities (for data channels)
              sctpCapabilities: device.sctpCapabilities || undefined
            });
            debugClient(`[makeTransport] Raw response from server for createWebRtcTransport (${direction}):`, JSON.parse(JSON.stringify(serverResponse))); // Log the raw response

            if (!serverResponse || !serverResponse.id) {
              const errorMsg = 'missing id in server response for createWebRtcTransport';
              console.error(`[makeTransport] ${errorMsg}`, serverResponse);
              log(`‚ùå ${errorMsg}`);
              throw new Error(errorMsg);
            }

            const { id: transportId, iceParameters, iceCandidates, dtlsParameters, sctpParameters } = serverResponse;
            debugClient(`[makeTransport] Server created ${direction} transport, (client-side transportId will be): ${transportId}`);

            const transportOptions = {
              id: transportId,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              iceServers: iceServersToUse, 
              iceTransportPolicy: 'relay', // Force using TURN relays instead of 'all'
              additionalSettings: {
                sdpSemantics: 'unified-plan',
                enableDtlsSrtp: true,
                iceCandidatePoolSize: 10 // Increase candidate pool
              }
            };
            
            debugClient(`[makeTransport] Using transportOptions for ${direction} transport:`, JSON.parse(JSON.stringify(transportOptions))); // Log the options

            const transport = direction === 'send' ?
              device.createSendTransport(transportOptions) :
              device.createRecvTransport(transportOptions);

            debugClient(`[makeTransport] Client-side ${direction} transport created: ${transport.id}`);

            transport.on('connect', async ({ dtlsParameters: connectDtlsParameters }, callback, errback) => {
              try {
                debugClient(`[transport ${direction} ${transport.id}] 'connect' event. DtlsParameters:`, connectDtlsParameters);
                await protooRequest('connectWebRtcTransport', { transportId: transport.id, dtlsParameters: connectDtlsParameters });
                debugClient(`[transport ${direction} ${transport.id}] Server acknowledged 'connectWebRtcTransport'.`);
                callback();
              } catch (error) {
                console.error(`[transport ${direction} ${transport.id}] 'connect' error:`, error);
                log(`‚ùå Error connecting ${direction} transport: ${error.message}`);
                errback(error);
              }
            });

            if (direction === 'send') {
              transport.on('produce', async ({ kind, rtpParameters, appData }, callback, errback) => {
                try {
                  debugClient(`[transport send ${transport.id}] 'produce' event. Kind: ${kind}, RtpParameters:`, rtpParameters, 'AppData:', appData);
                  const { id: producerId } = await protooRequest('produce', { transportId: transport.id, kind, rtpParameters, appData });
                  debugClient(`[transport send ${transport.id}] Server created producer: ${producerId} for kind ${kind}`);
                  callback({ id: producerId });
                } catch (error) {
                  console.error(`[transport send ${transport.id}] 'produce' error:`, error);
                  log(`‚ùå Error producing ${kind}: ${error.message}`);
                  errback(error);
                }
              });
            }

            transport.on('connectionstatechange', (state) => {
              console.log(`[transport ${direction} ${transport.id}] connection state changed to ${state}`);
              log(`üîÅ ${direction.charAt(0).toUpperCase() + direction.slice(1)} transport connection state: ${state}`);
              if (state === 'failed' || state === 'closed' || state === 'disconnected') {
                // Handle transport failure, maybe notify user or attempt reconnection
                console.warn(`[transport ${direction} ${transport.id}] Transport ${state}.`);
                // For now, just log. In a real app, might want to clean up or retry.
              }
            });
            
            transport.on('icecandidate', (candidate) => {
                debugClient(`[transport ${direction} ${transport.id}] ICE candidate:`, candidate);
                // In a typical client-server model with an SFU, you don't usually send ICE candidates
                // from client to server *after* initial transport creation, as the server provides its candidates.
                // However, some SFU designs might expect trickle ICE from client. Mediasoup-demo usually doesn't.
            });

            // Add an explicit debug log for ice gathering state changes
            transport.on('icegatheringstatechange', (state) => {
              debugClient(`[transport ${direction} ${transport.id}] ICE gathering state changed to ${state}`);
              log(`üßä ${direction.charAt(0).toUpperCase() + direction.slice(1)} transport ICE gathering: ${state}`);
            });

            return transport;
          } catch (error) {
            console.error(`[makeTransport] Error in makeTransport(${direction}):`, error);
            log(`‚ùå Error creating ${direction} transport: ${error.message}`);
            throw error; // Re-throw to be caught by joinSFU
          }
        }

        async function processPendingConsumers() {
          debugClient(`Processing ${pendingProducersToConsume.length} pending producers to consume.`);
          if (pendingProducersToConsume.length === 0) return;

          const producersToProcess = [...pendingProducersToConsume];
          pendingProducersToConsume = []; // Clear queue before processing to avoid re-entrancy issues
          debugClient(`Cleared pendingProducersToConsume queue. Now processing ${producersToProcess.length} producers.`);

          for (const producerInfo of producersToProcess) {
            debugClient(`Calling consumeProducer for queued producer: ${producerInfo.producerId}`);
            await consumeProducer(producerInfo);
          }
          debugClient(`Finished processing ${producersToProcess.length} pending producers.`);
        }

        async function consumeProducer(producerInfo) {
          const { peerId: producerPeerId, producerId, kind, appData } = producerInfo;
          debugClient(`[consumeProducer] START for producerId: ${producerId} from peer ${producerPeerId}`);
          console.log('üÜï consuming new producer notification', producerId, kind, appData, 'from peer', producerPeerId);
          log(`üÜï Seeing new producer: ${producerId} (${kind}) from peer ${producerPeerId}`);
          try {
            if (!device || !device.loaded) {
              const errMsg = 'Device not loaded at consumeProducer call';
              console.warn(`${errMsg} for ${producerId}`);
              log(`‚ö†Ô∏è ${errMsg} for ${producerId}`);
              // Queue it to try again later instead of just returning
              pendingProducersToConsume.push(producerInfo);
              return;
            }
            
            // Make sure we have a recv transport
            if (!recvTransport) {
              const errMsg = 'Receive transport not ready, cannot consume';
              console.warn(`${errMsg}. ProducerId: ${producerId}`);
              log(`‚ö†Ô∏è ${errMsg} for ${producerId}`);
              
              // If we were previously connected but lost the transport, try to recreate it
              if (device.loaded) {
                log(`üîÑ Attempting to recreate receive transport...`);
                try {
                  recvTransport = await makeTransport('recv');
                  log(`üëç Recreated receive transport: ${recvTransport.id}`);
                  // Now continue with consumption after a slight delay
                  setTimeout(() => consumeProducer(producerInfo), 500);
                  return;
                } catch (recreateErr) {
                  console.error('Failed to recreate receive transport', recreateErr);
                  log(`‚ùå Failed to recreate receive transport: ${recreateErr.message}`);
                  return;
                }
              }
              // If we couldn't recreate, just queue for later
              pendingProducersToConsume.push(producerInfo);
              return;
            }

            const { id: consumerId, producerId: remoteProducerIdReturned, kind: remoteKind, rtpParameters } = await protooRequest('consume', {
              rtpCapabilities: device.rtpCapabilities,
              producerId,
            });
            const consumer = await recvTransport.consume({
              id: consumerId,
              producerId: remoteProducerIdReturned, 
              kind: remoteKind, 
              rtpParameters: rtpParameters,
            });
            
            log(`üéß Consuming remote stream: ${producerId}`);
            debugClient(`[consumeProducer] Consumer ${consumer.id} created for producer ${producerId}. Initial client state: paused=${consumer.paused}, track=${!!consumer.track}`);
            
            await protooRequest('resumeConsumer', { consumerId: consumer.id });
            debugClient(`[consumeProducer] Server acknowledged resume request for consumer ${consumer.id}`);
            
            consumer.resume();
            log(`‚ñ∂Ô∏è Resumed remote stream: ${producerId}`);
            debugClient(`[consumeProducer] Client-side consumer.resume() called for ${consumer.id}. New client state: paused=${consumer.paused}, track=${!!consumer.track}`);

            function attachTrackToVideo(track) {
                if (!track || track.readyState !== 'live') {
                    debugClient(`[consumeProducer] Track for consumer ${consumer.id} is not live. State: ${track ? track.readyState : 'no track'}`);
                    log(`‚ö†Ô∏è Remote track for ${producerId} not live.`);
                    return;
                }
                debugClient(`[consumeProducer] Track for consumer ${consumer.id} is live. Attaching to remoteVideo.`);
                
                // Simplest assignment: Create a new MediaStream with just this track
                remoteVideo.srcObject = new MediaStream([track]);
                
                debugClient(`[attachTrackToVideo] remoteVideo.srcObject assigned with new MediaStream.`);
                // Add the detailed logging for tracks *after* assignment
                const stream = remoteVideo.srcObject;
                if (stream && typeof stream.getTracks === 'function') {
                    const tracks = stream.getTracks();
                    debugClient(`[attachTrackToVideo] MediaStream now has ${tracks.length} track(s).`);
                    tracks.forEach((t, index) => {
                        debugClient(`[attachTrackToVideo] Track ${index}: id=${t.id}, kind=${t.kind}, label='${t.label}', enabled=${t.enabled}, muted=${t.muted}, readyState=${t.readyState}`);
                        
                        // If track is muted, try to unmute after a short delay
                        if (t.muted) {
                            debugClient(`[attachTrackToVideo] Track ${index} is muted, will try to unmute shortly...`);
                            log(`üîá Remote track is muted, waiting for media...`);
                            
                            // Check muted state periodically
                            let unmuteTries = 0;
                            const maxTries = 30; // 30 seconds max
                            const checkInterval = setInterval(() => {
                                if (!t.muted || unmuteTries >= maxTries) {
                                    if (!t.muted) {
                                        debugClient(`[attachTrackToVideo] Track ${t.id} unmuted after ${unmuteTries} tries!`);
                                        log(`üîä Remote media flowing now!`);
                                    } else {
                                        debugClient(`[attachTrackToVideo] Track ${t.id} still muted after ${maxTries} tries.`);
                                        log(`‚ö†Ô∏è Remote media still muted after ${maxTries} seconds.`);
                                    }
                                    clearInterval(checkInterval);
                                }
                                unmuteTries++;
                            }, 1000);
                        }
                    });
                } else {
                    debugClient(`[attachTrackToVideo] remoteVideo.srcObject is null/undefined after new MediaStream assignment.`);
                }

                remoteVideo.play().then(() => {
                    debugClient(`[consumeProducer] remoteVideo.play() resolved for ${producerId}`);
                }).catch(e => {
                    console.warn(`[consumeProducer] remoteVideo.play() failed for ${producerId}:`, e);
                    log(`‚ö†Ô∏è Could not play remote video for ${producerId}. Autoplay might be blocked.`);
                });
                log(`üñºÔ∏è Displaying remote stream: ${producerId}`);
            }

            if (consumer.track) {
                attachTrackToVideo(consumer.track);
            } else {
                debugClient(`[consumeProducer] Track for consumer ${consumer.id} not immediately available after resume. Listening for 'trackstart'.`);
                consumer.once('trackstart', () => {
                    debugClient(`[consumeProducer] 'trackstart' event received for consumer ${consumer.id}.`);
                    attachTrackToVideo(consumer.track);
                });
            }
            
            consumer.on('trackended', () => {
                debugClient(`[consumeProducer] Consumer ${consumer.id} track ended. Clearing remote video.`);
                log(`üö´ Remote stream ended: ${producerId}`);
                if (remoteVideo.srcObject && typeof remoteVideo.srcObject.getTracks === 'function') {
                    const stream = remoteVideo.srcObject;
                    stream.getTracks().forEach(t => {
                        if (t.id === consumer.track.id) {
                            stream.removeTrack(t);
                        }
                    });
                    if (stream.getTracks().length === 0) {
                        remoteVideo.srcObject = null;
                    }
                }
            });
            consumer.on('producerpause', () => {
                debugClient(`[consumeProducer] Producer for consumer ${consumer.id} paused.`);
                log(`‚è∏Ô∏è Remote stream paused: ${producerId}`);
            });
            consumer.on('producerresume', () => {
                debugClient(`[consumeProducer] Producer for consumer ${consumer.id} resumed.`);
                log(`‚ñ∂Ô∏è Remote stream resumed by producer: ${producerId}`);
            });

          } catch (err) {
            console.error(`Error in consume request for producer ${producerId}:`, err);
            log(`‚ùå ERROR consuming producer ${producerId}: ${err.message}`);
            
            // If this was a transport error, we might need to recreate it
            if (err.message && err.message.includes('transport')) {
              log(`üîÑ Transport error detected. Will try to recreate transport on next attempt.`);
              if (recvTransport) {
                recvTransport.close();
                recvTransport = null;
              }
              // Queue the producer for later retry
              pendingProducersToConsume.push(producerInfo);
              // Try to recreate after a delay
              setTimeout(async () => {
                try {
                  log(`üîÑ Recreating receive transport after error...`);
                  recvTransport = await makeTransport('recv');
                  log(`‚úÖ Successfully recreated receive transport`);
                  // Process the pending queue
                  processPendingConsumers();
                } catch (recreateErr) {
                  console.error('Failed to recreate transport after error', recreateErr);
                  log(`‚ùå Failed to recreate transport: ${recreateErr.message}`);
                }
              }, 2000);
            }
          }
          debugClient(`[consumeProducer] END for producerId: ${producerId}`);
        }

        async function joinSFU(){
          log('üìπ Attempting to join SFU...'); 
          console.log('üìπ requesting camera');
          try {
            log(wantsVideo ? 'üé• Requesting video & audio...' : 'üé§ Requesting audio only...');
            localStream = await navigator.mediaDevices.getUserMedia({video: wantsVideo, audio:true});
            localVideo.srcObject = localStream; // Show local audio/video regardless
            log('üé§ Got local media stream.');
            console.log('üé§ got local media stream, wantsVideo:', wantsVideo);
            
            if (!window.mediasoupClient || !window.mediasoupClient.Device) { 
                const errMsg = 'mediasoupClient or mediasoupClient.Device is not available on window.';
                console.error(errMsg, window.mediasoupClient);
                log(`‚ùå ERROR: ${errMsg}`);
                return;
            }
            device = new window.mediasoupClient.Device(); 
            
            log('üöÄ Requesting Router RTP Capabilities...');
            const routerRtpCapabilities = await protooRequest('getRouterRtpCapabilities');
            console.log('üîß Received Router RTP Capabilities:', routerRtpCapabilities);
            log('üëç Got Router RTP Capabilities.');
            
            await device.load({ routerRtpCapabilities });
            console.log('üîß Device loaded with router capabilities');
            log('üëç Device loaded.');

            // Create both transports first
            log('üöö Creating send transport...');
            sendTransport = await makeTransport('send');
            console.log('üöö send transport ready', sendTransport.id);
            log(`üëç Send transport created: ${sendTransport.id}`);

            log('üì• Creating recv transport...');
            recvTransport = await makeTransport('recv');
            console.log('üì• recv transport ready', recvTransport.id);
            log(`üëç Recv transport created: ${recvTransport.id}`);
            
            // Now that transports (especially recvTransport) are ready, process pending consumers
            await processPendingConsumers();

            // Then produce local media
            if (wantsVideo) {
              const camTrack = localStream.getVideoTracks()[0];
              if (camTrack) {
                log('üì° Producing video track...');
                await sendTransport.produce({ track: camTrack, appData: { source: 'webcam' } }); 
                console.log('üì° produced local video');
                log('üì° Video produced.');
              } else {
                log('‚ö†Ô∏è No video track found to produce, even though wantsVideo was true.');
                console.warn('wantsVideo was true, but no video track found in localStream');
              }
            } else {
              log('‚ÑπÔ∏è Skipping video production as per ?novideo flag.');
            }
            
            // TODO: Implement audio production similarly if needed, or assume it's part of `sendTransport` handling if audio tracks are present.
            // For now, focusing on conditional video.

            log('üéß Listening for new producers (via global handler)...');
            aiGreeting();

            startWebRTCStats();

          } catch (err) {
            console.error('Error in joinSFU:', err);
            log(`‚ùå ERROR in joinSFU: ${err.message}`);
          }
        }
        
        // AI greeting after media & SFU ready (or at least initiated)
        async function aiGreeting(){
          const greetingPrompt = `Say: Hello ${userName}. Welcome to the session! How are things going with Ultra so far?`;
          const res = await fetch('/api/chat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message: greetingPrompt, userId:'<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: '+data.reply);
          // await logMessage('ai', data.reply); // logMessage might not be defined here.
          // playTTS(data.reply); // playTTS might not be defined here.
        }

        // Chat with AI (ensure logMessage and playTTS are available or remove)
        const inputEl = document.getElementById('msgInput');
        document.getElementById('sendBtn').onclick = async () => {
          const text = inputEl.value.trim();
          if(!text) return;
          log('You: ' + text);
          inputEl.value='';
          // await logMessage('client', text);
          const res  = await fetch('/api/chat', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ message: text, userId: '<%= user.id %>', sessionId }) });
          const data = await res.json();
          log('AI: ' + data.reply);
          // await logMessage('ai', data.reply);
          // playTTS(data.reply);
        };

        // Call timer & 15-minute callback
        const timerEl = document.getElementById('callTimer');
        let originTs = null;
        socket.on('room-start', ts => { originTs = ts; });

        let fifteenFired = false;
        setInterval(async () => {
          if(originTs === null) return;
          const elapsed = Math.floor((Date.now() - originTs)/1000);
          const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
          const ss = String(elapsed%60).padStart(2,'0');
          timerEl.textContent = `${mm}:${ss}`;

          if (!fifteenFired && elapsed >= 900){ // 15 minutes = 900 seconds
            fifteenFired = true;
            const note = 'System: The coach has another call in 5 minutes and will step away soon. Please provide any final recommendations for the next week of Ultra use.';
            // await logMessage('system', note);
            const res = await fetch('/api/chat', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ message: note, userId:'<%= user.id %>', sessionId }) });
            const data = await res.json();
            log('AI: '+data.reply);
            // await logMessage('ai', data.reply);
            // playTTS(data.reply);
          }
        },1000);
        
      }); // End of waitForDependencies callback
    </script>
  </body>
</html> 