<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElevenLabs Widget Inspector</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .widget-demo {
            border: 3px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            background: #fff;
            width: 640px;
            height: 480px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .widget-capture {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }
        
        .widget-capture.active {
            display: block;
            background: rgba(0,0,0,0.3);
        }
        
        .captured-widget {
            border: 2px dashed #3498db;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
        }
        
        .transcript-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        
        .transcript-entry {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
        }
        
        .transcript-entry.user {
            background: rgba(52, 152, 219, 0.3);
            text-align: right;
        }
        
        .transcript-entry.ai {
            background: rgba(46, 204, 113, 0.3);
            text-align: left;
        }
        
        .canvas-capture {
            border: 3px solid #9b59b6;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            text-align: center;
        }
        
        .captured-canvas {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 10px;
            display: inline-block;
        }
        
        .genie-bottle {
            width: 200px;
            height: 200px;
            border: 4px solid #f39c12;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #3498db, #2980b9, #1abc9c);
            margin: 20px auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.8);
        }
        
        .genie-bottle canvas {
            width: 100% !important;
            height: 100% !important;
            border-radius: 50%;
        }
        
        .widget-controller {
            border: 3px solid #e74c3c;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }
        
        .controlled-overlay {
            position: relative !important;
            display: block !important;
            width: 100% !important;
            max-width: 600px !important;
            height: auto !important;
            max-height: none !important;
            bottom: auto !important;
            right: auto !important;
            margin: 20px auto !important;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3) !important;
        }
        
        .widget-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
            font-size: 18px;
            text-align: center;
            border-radius: 7px;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .info-section {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(116, 185, 255, 0.3);
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #e74c3c;
        }
        
        .console-output {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
            border: 2px solid #333;
        }
        
        .warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #d63031;
        }
        
        .method-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .method-card {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
            transition: transform 0.3s ease;
        }
        
        .method-card:hover {
            transform: translateY(-5px);
        }
        
        .method-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }
        
        .orb-simulator {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #00f5ff, #0099cc, #006699);
            margin: 20px auto;
            position: relative;
            animation: pulse 2s infinite;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 30px rgba(0, 245, 255, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(0, 245, 255, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 30px rgba(0, 245, 255, 0.5); }
        }
        
        .talking {
            animation: talk 0.5s infinite alternate;
        }
        
        @keyframes talk {
            0% { background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a24, #d63031); }
            100% { background: radial-gradient(circle at 30% 30%, #ff9ff3, #f368e0, #e84393); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ ElevenLabs Widget Inspector</h1>
        
        <div class="widget-demo">
            <div class="widget-placeholder">
                <div>
                    <div class="orb-simulator" id="orb"></div>
                    <p>ElevenLabs Widget Simulation<br>
                    <small>Click buttons below to test different states</small></p>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="loadWidget()">üîÑ Load Real Widget</button>
            <button onclick="inspectWidget()">üîç Inspect Widget Code</button>
            <button onclick="captureOverlay()">üì∏ Capture Overlay Widget</button>
            <button onclick="findWidgetInDOM()">üéØ Find Widget in DOM</button>
            <button onclick="extractCSS()">üé® Extract CSS</button>
            <button onclick="monitorNetwork()">üì° Monitor Network</button>
            <button onclick="interceptTranscript()">üìù Intercept Transcript</button>
            <button onclick="forceInlineWidget()">üì¶ Force Inline Display</button>
            <button onclick="captureCanvas()">üé® Capture Canvas Animation</button>
            <button onclick="createGenieBottle()">üßû Create Genie Bottle</button>
            <button onclick="controlWidget()">üéÆ Control Widget</button>
            <button onclick="simulateClick()">üëÜ Simulate Click</button>
            <button onclick="hijackOverlay()">üéØ Hijack Overlay</button>
            <button onclick="testCustomCommand()">üì§ Test Custom Command</button>
            <button onclick="testUpdateContext()">üîÑ Test Update Context</button>
        </div>
        
        <div class="info-section">
            <h3>üîç Widget Inspection Methods</h3>
            <p>Here are several ways to examine the ElevenLabs widget code and understand how it works:</p>
        </div>
        
        <div class="method-list">
            <div class="method-card">
                <div class="method-title">1. Browser Developer Tools</div>
                <p>Use F12 to open DevTools, then inspect the DOM after the widget loads. You can see the generated HTML structure and CSS styles.</p>
            </div>
            
            <div class="method-card">
                <div class="method-title">2. Network Tab Analysis</div>
                <p>Monitor the Network tab to see what files are loaded, API calls made, and resources fetched by the widget.</p>
            </div>
            
            <div class="method-card">
                <div class="method-title">3. Source Code Inspection</div>
                <p>The widget script is likely minified, but you can still examine it in the Sources tab of DevTools.</p>
            </div>
            
            <div class="method-card">
                <div class="method-title">4. Runtime Manipulation</div>
                <p>Use the Console to interact with the widget's JavaScript objects and methods in real-time.</p>
            </div>
        </div>
        
        <div class="code-block">
// Example: Inspect widget after loading
setTimeout(() => {
    const widget = document.querySelector('elevenlabs-convai');
    console.log('Widget element:', widget);
    console.log('Widget properties:', Object.getOwnPropertyNames(widget));
    
    // Look for shadow DOM
    if (widget.shadowRoot) {
        console.log('Shadow DOM found:', widget.shadowRoot);
    }
}, 3000);
        </div>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Important Notes:</strong>
            <ul>
                <li>The widget code is likely minified and obfuscated</li>
                <li>It may use Shadow DOM, making inspection more complex</li>
                <li>Some functionality might be server-side rendered</li>
                <li>Real-time audio processing happens in the browser</li>
            </ul>
        </div>
        
        <div class="console-output" id="console">
            <div>Console output will appear here...</div>
        </div>
        
        <div class="captured-widget" id="captured-widget" style="display: none;">
            <h3>üì∏ Captured Widget Structure</h3>
            <div id="widget-structure"></div>
        </div>
        
        <div class="transcript-display" id="transcript-display" style="display: none;">
            <h3>üìù Live Transcript</h3>
            <div id="transcript-content"></div>
        </div>
        
        <div class="canvas-capture" id="canvas-capture" style="display: none;">
            <h3>üé® Captured Canvas Animation</h3>
            <div id="canvas-container"></div>
            <div class="genie-bottle" id="genie-bottle" style="display: none;">
                <canvas id="genie-canvas" width="200" height="200"></canvas>
            </div>
        </div>
        
        <div class="widget-controller" id="widget-controller" style="display: none;">
            <h3>üéÆ Widget Controller</h3>
            <div id="controlled-overlay-container"></div>
            <div style="margin-top: 15px;">
                <button onclick="startCall()" style="margin: 5px; padding: 10px 15px; background: #27ae60; border: none; border-radius: 5px; color: white;">üìû Start Call</button>
                <button onclick="endCall()" style="margin: 5px; padding: 10px 15px; background: #e74c3c; border: none; border-radius: 5px; color: white;">üìµ End Call</button>
                <button onclick="toggleOverlay()" style="margin: 5px; padding: 10px 15px; background: #f39c12; border: none; border-radius: 5px; color: white;">üëÅÔ∏è Toggle Overlay</button>
                <button onclick="extractCanvasFromOverlay()" style="margin: 5px; padding: 10px 15px; background: #9b59b6; border: none; border-radius: 5px; color: white;">üé® Extract Canvas</button>
            </div>
        </div>
    </div>
    
    <div class="widget-capture" id="widget-capture"></div>

    <script>
        let isListening = false;
        let isTalking = false;
        
        // Widget hijacking controller
        class WidgetHijacker {
            constructor() {
                this.conversation = null;
                this.initializeWidget();
            }
            
            async initializeWidget() {
                // Load the ElevenLabs widget first
                await this.loadElevenLabsWidget();
                
                // Then hijack it
                setTimeout(() => {
                    this.hijackWidget();
                }, 3000);
            }
            
            async loadElevenLabsWidget() {
                return new Promise((resolve) => {
                    // Wait for widget to be loaded
                    const checkInterval = setInterval(() => {
                        const widget = document.querySelector('elevenlabs-convai');
                        if (widget && customElements.get('elevenlabs-convai')) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
            }
            
            hijackWidget() {
                const widget = document.querySelector('elevenlabs-convai');
                
                if (!widget) {
                    log('‚ùå Widget not found for hijacking');
                    return;
                }
                
                log('üéØ Attempting to hijack widget...');
                
                // Find the conversation instance (inspect to find exact property name)
                this.conversation = widget._convai || widget.conversation;
                
                if (this.conversation) {
                    log('‚úÖ Found conversation instance!');
                    
                    // Override event handlers
                    this.conversation.options.onMessage = this.handleMessage.bind(this);
                    this.conversation.options.onModeChange = this.handleModeChange.bind(this);
                    this.conversation.options.onStatusChange = this.handleStatusChange.bind(this);
                    
                    // Add your custom methods
                    this.setupCustomMethods();
                } else {
                    log('‚ö†Ô∏è Could not find conversation instance, trying alternative methods...');
                    this.tryAlternativeHijack(widget);
                }
            }
            
            tryAlternativeHijack(widget) {
                // Try to access through prototype or shadow DOM
                const props = Object.getOwnPropertyNames(widget);
                log(`üîç Widget properties: ${props.join(', ')}`);
                
                // Look for conversation-related properties
                for (const prop of props) {
                    if (prop.includes('conv') || prop.includes('chat') || prop.includes('message')) {
                        log(`üéØ Found potential conversation property: ${prop}`);
                        this.conversation = widget[prop];
                        if (this.conversation) break;
                    }
                }
                
                // Try shadow DOM approach
                if (!this.conversation && widget.shadowRoot) {
                    const shadowProps = Array.from(widget.shadowRoot.querySelectorAll('*'))
                        .filter(el => el.conversation || el._convai);
                    if (shadowProps.length > 0) {
                        this.conversation = shadowProps[0].conversation || shadowProps[0]._convai;
                        log('‚úÖ Found conversation in shadow DOM!');
                    }
                }
            }
            
            handleMessage({source, message}) {
                log(`üí¨ Message intercepted - Source: ${source}, Message: ${message}`);
                
                if (source === 'ai') {
                    // AI responded - update your custom UI
                    this.updateOrbAnimation('speaking');
                    this.displayAIResponse(message);
                } else {
                    // User spoke - show listening state
                    this.updateOrbAnimation('listening');
                    this.displayUserMessage(message);
                }
            }
            
            handleModeChange(mode) {
                log(`üîÑ Mode changed to: ${mode}`);
            }
            
            handleStatusChange(status) {
                log(`üìä Status changed to: ${status}`);
            }
            
            setupCustomMethods() {
                log('üõ†Ô∏è Setting up custom methods...');
                
                // Add custom command sender
                window.sendCustomCommand = this.sendCustomCommand.bind(this);
                window.updateContext = this.updateContext.bind(this);
                
                log('‚úÖ Custom methods ready: sendCustomCommand(), updateContext()');
            }
            
            // Your custom methods
            sendCustomCommand(command) {
                if (!this.conversation) {
                    log('‚ùå No conversation instance available');
                    return;
                }
                
                log(`üì§ Sending custom command: ${command}`);
                
                // Try different methods to send message
                if (this.conversation.sendUserMessage) {
                    this.conversation.sendUserMessage(`Execute: ${command}`);
                } else if (this.conversation.send) {
                    this.conversation.send(`Execute: ${command}`);
                } else if (this.conversation.postMessage) {
                    this.conversation.postMessage({type: 'user', message: `Execute: ${command}`});
                } else {
                    log('‚ùå Could not find send method');
                }
            }
            
            updateContext(contextInfo) {
                if (!this.conversation) {
                    log('‚ùå No conversation instance available');
                    return;
                }
                
                log(`üîÑ Updating context: ${JSON.stringify(contextInfo)}`);
                
                if (this.conversation.sendContextualUpdate) {
                    this.conversation.sendContextualUpdate(contextInfo);
                } else if (this.conversation.updateContext) {
                    this.conversation.updateContext(contextInfo);
                } else {
                    log('‚ùå Could not find context update method');
                }
            }
            
            updateOrbAnimation(state) {
                const orb = document.getElementById('orb');
                if (!orb) return;
                
                orb.classList.remove('talking', 'listening');
                
                switch(state) {
                    case 'speaking':
                        orb.classList.add('talking');
                        log('üó£Ô∏è Orb: Speaking animation');
                        break;
                    case 'listening':
                        orb.classList.add('listening');
                        log('üëÇ Orb: Listening animation');
                        break;
                    default:
                        log('üîá Orb: Idle');
                }
            }
            
            displayAIResponse(message) {
                const transcriptDiv = document.getElementById('transcript-display');
                const contentDiv = document.getElementById('transcript-content');
                
                if (!transcriptDiv || !contentDiv) return;
                
                transcriptDiv.style.display = 'block';
                
                const entry = document.createElement('div');
                entry.className = 'transcript-entry ai';
                entry.textContent = `AI: ${message}`;
                contentDiv.appendChild(entry);
                contentDiv.scrollTop = contentDiv.scrollHeight;
            }
            
            displayUserMessage(message) {
                const transcriptDiv = document.getElementById('transcript-display');
                const contentDiv = document.getElementById('transcript-content');
                
                if (!transcriptDiv || !contentDiv) return;
                
                transcriptDiv.style.display = 'block';
                
                const entry = document.createElement('div');
                entry.className = 'transcript-entry user';
                entry.textContent = `User: ${message}`;
                contentDiv.appendChild(entry);
                contentDiv.scrollTop = contentDiv.scrollHeight;
            }
        }
        
        // Initialize widget hijacker instance
        let widgetHijacker = null;
        
        function log(message) {
            const console = document.getElementById('console');
            const div = document.createElement('div');
            div.innerHTML = `<span style="color: #00ff00;">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            console.appendChild(div);
            console.scrollTop = console.scrollHeight;
        }
        
        function loadWidget() {
            log('üîÑ Attempting to load real ElevenLabs widget...');
            
            // Check if script is already loaded
            const existingScript = document.querySelector('script[src*="elevenlabs/convai-widget-embed"]');
            if (existingScript) {
                log('‚ö†Ô∏è Removing existing ElevenLabs script...');
                existingScript.remove();
            }
            
            // Clear existing content
            const widgetContainer = document.querySelector('.widget-demo');
            widgetContainer.innerHTML = '';
            widgetContainer.style.background = 'transparent';
            widgetContainer.style.border = 'none';
            widgetContainer.style.padding = '0';
            widgetContainer.style.width = 'auto';
            widgetContainer.style.height = 'auto';
            
            // Create the custom element
            const widgetElement = document.createElement('elevenlabs-convai');
            widgetElement.setAttribute('agent-id', 'agent_01jy88zv6zfe1a9v9zdxt69abd');
            widgetContainer.appendChild(widgetElement);
            
            // Load the script
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/@elevenlabs/convai-widget-embed';
            script.type = 'text/javascript';
            script.async = true;
            
            script.onload = () => {
                log('‚úÖ ElevenLabs script loaded successfully!');
                
                // Monitor for custom element registration
                let checkCount = 0;
                const checkInterval = setInterval(() => {
                    checkCount++;
                    
                    if (customElements.get('elevenlabs-convai')) {
                        clearInterval(checkInterval);
                        log('‚úÖ Custom element is now registered!');
                        log('üé§ Widget should be ready for conversation');
                        
                        // Force a small delay to ensure full initialization
                        setTimeout(() => {
                            const widget = document.querySelector('elevenlabs-convai');
                            if (widget) {
                                log('‚úÖ Widget is in DOM and ready to use!');
                                log('üí° You can now click on the widget to start a conversation');
                                
                                // Initialize the widget hijacker only if not already initialized
                                if (!widgetHijacker) {
                                    widgetHijacker = new WidgetHijacker();
                                    log('üéØ Widget hijacker initialized!');
                                }
                            }
                        }, 500);
                    } else if (checkCount > 20) { // 10 seconds timeout
                        clearInterval(checkInterval);
                        log('‚ùå Timeout waiting for custom element registration');
                    } else {
                        log(`‚è≥ Waiting for custom element registration... (${checkCount * 500}ms)`);
                    }
                }, 500);
            };
            
            script.onerror = (error) => {
                log('‚ùå Failed to load ElevenLabs script');
                log(`‚ùå Error: ${error.message || 'Script loading failed'}`);
            };
            
            document.body.appendChild(script);
            log('üì¶ Script tag added to document body...');
        }
        
        function inspectWidget() {
            log('üîç Inspecting widget structure...');
            
            const widget = document.querySelector('elevenlabs-convai');
            if (!widget) {
                log('‚ùå Widget not found. Load it first.');
                return;
            }
            
            log(`üìä Widget tag name: ${widget.tagName}`);
            log(`üìä Widget attributes: ${Array.from(widget.attributes).map(attr => `${attr.name}="${attr.value}"`).join(', ')}`);
            
            // Check if custom element is defined
            const elementDef = customElements.get('elevenlabs-convai');
            if (elementDef) {
                log('‚úÖ Custom element is defined');
                log(`üìä Element constructor: ${elementDef.name}`);
            } else {
                log('‚ö†Ô∏è Custom element not yet defined');
            }
            
            // Check for Shadow DOM
            if (widget.shadowRoot) {
                log('üåü Shadow DOM detected!');
                log(`üìä Shadow DOM mode: ${widget.shadowRoot.mode}`);
                log(`üìä Shadow DOM innerHTML length: ${widget.shadowRoot.innerHTML.length} characters`);
                
                // Try to find interesting elements in shadow DOM
                const shadowElements = widget.shadowRoot.querySelectorAll('*');
                log(`üìä Shadow DOM contains ${shadowElements.length} elements`);
                
                // Look for audio/video elements
                const audioElements = widget.shadowRoot.querySelectorAll('audio');
                const videoElements = widget.shadowRoot.querySelectorAll('video');
                if (audioElements.length > 0) log(`üéµ Found ${audioElements.length} audio elements`);
                if (videoElements.length > 0) log(`üé• Found ${videoElements.length} video elements`);
            } else {
                log('‚ö†Ô∏è No Shadow DOM found (may be closed)');
            }
            
            // Check for methods and properties
            const props = Object.getOwnPropertyNames(widget);
            const methods = props.filter(prop => typeof widget[prop] === 'function');
            
            if (props.length > 0) {
                log(`üìä Widget properties (${props.length} total): ${props.slice(0, 10).join(', ')}${props.length > 10 ? '...' : ''}`);
            }
            
            if (methods.length > 0) {
                log(`üìä Widget methods (${methods.length} total): ${methods.slice(0, 10).join(', ')}${methods.length > 10 ? '...' : ''}`);
            }
            
            // Look for global ElevenLabs objects
            if (window.ElevenLabs) {
                log('üåü Global ElevenLabs object found!');
                log(`üìä ElevenLabs methods: ${Object.keys(window.ElevenLabs).join(', ')}`);
            }
            
            // Check for event listeners
            log('üéØ Attempting to detect event listeners...');
            if (widget.getEventListeners) {
                const listeners = widget.getEventListeners();
                log(`üìä Event listeners: ${JSON.stringify(listeners)}`);
            }
        }
        
        function simulateTalking() {
            const orb = document.getElementById('orb');
            isTalking = !isTalking;
            
            if (isTalking) {
                orb.classList.add('talking');
                log('üó£Ô∏è Simulating talking state...');
            } else {
                orb.classList.remove('talking');
                log('üîá Stopped talking simulation');
            }
        }
        
        function simulateListening() {
            isListening = !isListening;
            log(isListening ? 'üëÇ Simulating listening state...' : 'üîá Stopped listening simulation');
        }
        
        function extractCSS() {
            log('üé® Extracting CSS styles...');
            
            const widget = document.querySelector('elevenlabs-convai');
            if (!widget) {
                log('‚ùå Widget not found. Load it first.');
                return;
            }
            
            // Get computed styles
            const styles = window.getComputedStyle(widget);
            const importantStyles = ['display', 'position', 'width', 'height', 'background', 'border-radius', 'z-index', 'overflow'];
            
            log('üé® Widget computed styles:');
            importantStyles.forEach(prop => {
                const value = styles.getPropertyValue(prop);
                if (value && value !== 'auto' && value !== 'none') {
                    log(`  ${prop}: ${value}`);
                }
            });
            
            // Get widget dimensions
            const rect = widget.getBoundingClientRect();
            log(`üìè Widget dimensions: ${rect.width}x${rect.height} at (${rect.x}, ${rect.y})`);
            
            // Check for shadow DOM styles
            if (widget.shadowRoot) {
                const shadowStyles = widget.shadowRoot.querySelectorAll('style');
                log(`üé® Found ${shadowStyles.length} style elements in shadow DOM`);
                
                // Try to extract some style content
                shadowStyles.forEach((style, index) => {
                    const content = style.textContent;
                    if (content) {
                        log(`üé® Style block ${index + 1} preview: ${content.substring(0, 100)}...`);
                    }
                });
                
                // Look for specific UI elements
                const buttons = widget.shadowRoot.querySelectorAll('button');
                const inputs = widget.shadowRoot.querySelectorAll('input, textarea');
                if (buttons.length > 0) log(`üîò Found ${buttons.length} buttons`);
                if (inputs.length > 0) log(`üìù Found ${inputs.length} input elements`);
            }
        }
        
        function monitorNetwork() {
            log('üì° Starting AGGRESSIVE network monitoring...');
            log('üí° Monitoring ALL requests - ElevenLabs calls will be highlighted');
            log('üîç Also monitoring: WebSockets, fetch, XHR, and resource loads');
            
            // Monitor ALL network activity counter
            let requestCount = 0;
            
            // Store original functions
            if (!window._originalFetch) {
                window._originalFetch = window.fetch;
                window._originalXHR = window.XMLHttpRequest;
                window._originalWebSocket = window.WebSocket;
            }
            
            // Monkey patch fetch to monitor requests
            window.fetch = function(...args) {
                const url = args[0];
                const options = args[1] || {};
                requestCount++;
                
                // Log ALL requests but highlight ElevenLabs
                const isElevenLabs = url.includes('elevenlabs') || url.includes('eleven') || 
                                   url.includes('convai') || url.includes('11labs') || 
                                   url.includes('speechify') || url.includes('websocket');
                
                if (isElevenLabs) {
                    log(`üéØ [${requestCount}] ELEVENLABS Fetch: ${options.method || 'GET'} ${url}`);
                    log(`  üìã Headers: ${JSON.stringify(options.headers || {})}`);
                    
                    // Log request body if present
                    if (options.body) {
                        try {
                            const bodyPreview = typeof options.body === 'string' ? 
                                options.body.substring(0, 200) : 
                                `Binary data (${options.body.byteLength || 'unknown'} bytes)`;
                            log(`  üì§ Body: ${bodyPreview}${bodyPreview.length > 200 ? '...' : ''}`);
                        } catch (e) {
                            log(`  üì§ Body: [Unable to read]`);
                        }
                    }
                } else {
                    // Still log other requests but less verbose
                    log(`üì° [${requestCount}] Fetch: ${options.method || 'GET'} ${url.substring(0, 100)}...`);
                }
                
                const startTime = Date.now();
                return window._originalFetch.apply(this, args)
                    .then(response => {
                        const duration = Date.now() - startTime;
                        if (isElevenLabs) {
                            log(`  ‚úÖ ELEVENLABS Response: ${response.status} ${response.statusText} (${duration}ms)`);
                            log(`  üìã Response Headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()))}`);
                            
                            // Clone response to read body without consuming it
                            const clonedResponse = response.clone();
                            clonedResponse.text().then(body => {
                                log(`  üì• Response Body Preview: ${body.substring(0, 200)}...`);
                            }).catch(() => {
                                log(`  üì• Response Body: [Binary or stream data]`);
                            });
                        } else {
                            log(`  ‚úÖ Response [${requestCount}]: ${response.status} (${duration}ms)`);
                        }
                        return response;
                    })
                    .catch(error => {
                        if (isElevenLabs) {
                            log(`  ‚ùå ELEVENLABS Error: ${error.message}`);
                            log(`  üìã Error Stack: ${error.stack}`);
                        } else {
                            log(`  ‚ùå Error [${requestCount}]: ${error.message}`);
                        }
                        throw error;
                    });
            };
            
            // Monitor XHR requests
            window.XMLHttpRequest = function() {
                const xhr = new window._originalXHR();
                const originalOpen = xhr.open;
                const originalSend = xhr.send;
                
                let xhrUrl = '';
                let xhrMethod = '';
                requestCount++;
                
                xhr.open = function(method, url) {
                    xhrMethod = method;
                    xhrUrl = url;
                    
                    const isElevenLabs = url.includes('elevenlabs') || url.includes('eleven') || 
                                       url.includes('convai') || url.includes('11labs');
                    
                    if (isElevenLabs) {
                        log(`üéØ [${requestCount}] ELEVENLABS XHR: ${method} ${url}`);
                    } else {
                        log(`üì° [${requestCount}] XHR: ${method} ${url.substring(0, 100)}...`);
                    }
                    
                    return originalOpen.apply(this, arguments);
                };
                
                xhr.send = function(data) {
                    const isElevenLabs = xhrUrl.includes('elevenlabs') || xhrUrl.includes('eleven') || 
                                       xhrUrl.includes('convai') || xhrUrl.includes('11labs');
                    
                    if (data) {
                        try {
                            const preview = typeof data === 'string' ? 
                                data.substring(0, 200) : 
                                `Binary data (${data.byteLength || 'unknown'} bytes)`;
                            if (isElevenLabs) {
                                log(`  üì§ ELEVENLABS XHR Body: ${preview}${preview.length > 200 ? '...' : ''}`);
                            }
                        } catch (e) {}
                    }
                    
                    const startTime = Date.now();
                    
                    // Monitor response
                    xhr.addEventListener('load', function() {
                        const duration = Date.now() - startTime;
                        if (isElevenLabs) {
                            log(`  ‚úÖ ELEVENLABS XHR Response: ${this.status} ${this.statusText} (${duration}ms)`);
                            try {
                                log(`  üì• XHR Response Preview: ${this.responseText.substring(0, 200)}...`);
                            } catch (e) {}
                        } else {
                            log(`  ‚úÖ XHR Response [${requestCount}]: ${this.status} (${duration}ms)`);
                        }
                    });
                    
                    xhr.addEventListener('error', function() {
                        log(`  ‚ùå ${isElevenLabs ? 'ELEVENLABS ' : ''}XHR Error [${requestCount}]`);
                    });
                    
                    return originalSend.apply(this, arguments);
                };
                
                return xhr;
            };
            
            // Monitor WebSocket connections
            window.WebSocket = function(url, protocols) {
                log(`üåê WebSocket Connection: ${url}`);
                log(`  üìã Protocols: ${protocols || 'none'}`);
                
                const ws = new window._originalWebSocket(url, protocols);
                
                // Monitor WebSocket events
                ws.addEventListener('open', function(event) {
                    log(`  ‚úÖ WebSocket OPENED: ${url}`);
                });
                
                ws.addEventListener('message', function(event) {
                    const dataPreview = typeof event.data === 'string' ? 
                        event.data.substring(0, 100) : 
                        `Binary data (${event.data.byteLength || 'unknown'} bytes)`;
                    log(`  üì® WebSocket MESSAGE: ${dataPreview}${dataPreview.length > 100 ? '...' : ''}`);
                });
                
                ws.addEventListener('error', function(event) {
                    log(`  ‚ùå WebSocket ERROR: ${url}`);
                });
                
                ws.addEventListener('close', function(event) {
                    log(`  üîå WebSocket CLOSED: ${url} (code: ${event.code}, reason: ${event.reason})`);
                });
                
                // Monitor outgoing messages
                const originalSend = ws.send;
                ws.send = function(data) {
                    const dataPreview = typeof data === 'string' ? 
                        data.substring(0, 100) : 
                        `Binary data (${data.byteLength || 'unknown'} bytes)`;
                    log(`  üì§ WebSocket SEND: ${dataPreview}${dataPreview.length > 100 ? '...' : ''}`);
                    return originalSend.apply(this, arguments);
                };
                
                return ws;
            };
            
            // Monitor Performance API for resource timing
            const observer = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                entries.forEach(entry => {
                    if (entry.name.includes('elevenlabs') || entry.name.includes('convai')) {
                        log(`üéØ RESOURCE Loaded: ${entry.name} (${Math.round(entry.duration)}ms)`);
                    }
                });
            });
            observer.observe({ entryTypes: ['resource'] });
            
            log('‚úÖ AGGRESSIVE Network monitoring active!');
            log('üìä Monitoring: fetch, XHR, WebSocket, and resource loads');
            log('üéØ ElevenLabs requests will be highlighted');
            log('üí° Now interact with the widget to see all network activity!');
        }
        
        // Additional utility functions
        function checkWidgetStatus() {
            const widget = document.querySelector('elevenlabs-convai');
            if (!widget) {
                log('‚ùå No widget element found');
                return;
            }
            
            log('üìä Widget Status Check:');
            log(`  Element exists: ‚úÖ`);
            log(`  Custom element defined: ${customElements.get('elevenlabs-convai') ? '‚úÖ' : '‚ùå'}`);
            log(`  Has shadow root: ${widget.shadowRoot ? '‚úÖ' : '‚ùå'}`);
            log(`  Parent visible: ${widget.offsetParent !== null ? '‚úÖ' : '‚ùå'}`);
            log(`  Dimensions: ${widget.offsetWidth}x${widget.offsetHeight}`);
            
            // Check for ElevenLabs global
            if (window.ElevenLabs) {
                log(`  ElevenLabs global: ‚úÖ`);
                log(`  ElevenLabs version: ${window.ElevenLabs.version || 'Unknown'}`);
            } else {
                log(`  ElevenLabs global: ‚ùå`);
            }
        }
        
        function debugLoadingIssues() {
            log('üîß Debugging widget loading issues...');
            
            // Check for script in DOM
            const scripts = Array.from(document.querySelectorAll('script'));
            const elevenLabsScript = scripts.find(s => s.src.includes('elevenlabs'));
            
            if (elevenLabsScript) {
                log(`‚úÖ ElevenLabs script found: ${elevenLabsScript.src}`);
                log(`  Async: ${elevenLabsScript.async}`);
                log(`  Defer: ${elevenLabsScript.defer}`);
            } else {
                log('‚ùå No ElevenLabs script found in DOM');
            }
            
            // Check for CORS issues
            log('üîç Checking for potential CORS issues...');
            fetch('https://unpkg.com/@elevenlabs/convai-widget-embed', { mode: 'cors' })
                .then(response => {
                    log(`‚úÖ Script accessible via CORS (status: ${response.status})`);
                })
                .catch(error => {
                    log(`‚ùå CORS error accessing script: ${error.message}`);
                });
            
            // Check custom elements registry
            log('üîç Custom Elements Registry:');
            const definedElements = ['elevenlabs-convai', 'elevenlabs-widget', 'el-convai'];
            definedElements.forEach(name => {
                const isDefined = customElements.get(name);
                if (isDefined) {
                    log(`  ${name}: ‚úÖ Defined`);
                } else {
                    log(`  ${name}: ‚ùå Not defined`);
                }
            });
        }
        
        // Auto-debug on page load
        window.addEventListener('load', () => {
            log('üåê Page fully loaded');
            debugLoadingIssues();
        });
        
        // Additional functions for overlay widget capture
        function captureOverlay() {
            log('üì∏ Attempting to capture overlay widget...');
            
            // Look for common overlay patterns
            const possibleSelectors = [
                'elevenlabs-convai',
                '[class*="elevenlabs"]',
                '[class*="convai"]',
                '[class*="widget"]',
                '[style*="fixed"]',
                '[style*="z-index: 9"]',
                'iframe[src*="elevenlabs"]',
                'div[data-elevenlabs]'
            ];
            
            let foundWidget = null;
            for (const selector of possibleSelectors) {
                const elements = document.querySelectorAll(selector);
                for (const el of elements) {
                    const rect = el.getBoundingClientRect();
                    const styles = window.getComputedStyle(el);
                    
                    // Check if it's positioned as an overlay
                    if (styles.position === 'fixed' || 
                        styles.position === 'absolute' && 
                        (styles.bottom === '0px' || rect.bottom === window.innerHeight)) {
                        
                        log(`‚úÖ Found potential widget: ${el.tagName} with class "${el.className}"`);
                        log(`üìè Position: ${styles.position}, Bottom: ${styles.bottom}, Right: ${styles.right}`);
                        log(`üìè Dimensions: ${rect.width}x${rect.height}`);
                        log(`üìè Z-index: ${styles.zIndex}`);
                        
                        foundWidget = el;
                        displayCapturedWidget(el);
                    }
                }
            }
            
            if (!foundWidget) {
                log('‚ùå No overlay widget found. Try loading the widget first.');
                
                // Try shadow DOM roots
                const allElements = document.querySelectorAll('*');
                for (const el of allElements) {
                    if (el.shadowRoot) {
                        log(`üåü Found shadow root on ${el.tagName}`);
                        inspectShadowRoot(el);
                    }
                }
            }
        }
        
        function findWidgetInDOM() {
            log('üéØ Deep scanning DOM for widget elements...');
            
            const widgetSignatures = [];
            
            // Scan all elements
            const allElements = document.querySelectorAll('*');
            log(`üìä Total elements in DOM: ${allElements.length}`);
            
            allElements.forEach(el => {
                // Check for ElevenLabs attributes or classes
                if (el.tagName.toLowerCase().includes('eleven') || 
                    el.className.toString().includes('eleven') ||
                    el.id && el.id.includes('eleven')) {
                    
                    widgetSignatures.push({
                        tag: el.tagName,
                        id: el.id,
                        class: el.className.toString(),
                        position: window.getComputedStyle(el).position,
                        display: window.getComputedStyle(el).display,
                        shadowRoot: !!el.shadowRoot
                    });
                }
                
                // Check for custom elements
                if (el.tagName.includes('-')) {
                    log(`üîß Custom element found: ${el.tagName}`);
                }
            });
            
            if (widgetSignatures.length > 0) {
                log('‚úÖ Found widget elements:');
                widgetSignatures.forEach(sig => {
                    log(`  - ${sig.tag} #${sig.id} .${sig.class} (${sig.position}, shadow: ${sig.shadowRoot})`);
                });
            }
            
            // Check for iframes
            const iframes = document.querySelectorAll('iframe');
            if (iframes.length > 0) {
                log(`üñºÔ∏è Found ${iframes.length} iframes`);
                iframes.forEach((iframe, i) => {
                    log(`  - Iframe ${i}: ${iframe.src || 'no src'} (${iframe.width}x${iframe.height})`);
                });
            }
        }
        
        function displayCapturedWidget(element) {
            const captureDiv = document.getElementById('captured-widget');
            const structureDiv = document.getElementById('widget-structure');
            
            captureDiv.style.display = 'block';
            
            // Build structure representation
            const structure = buildElementStructure(element);
            structureDiv.innerHTML = `<pre>${JSON.stringify(structure, null, 2)}</pre>`;
        }
        
        function buildElementStructure(element, depth = 0) {
            if (depth > 5) return '...';
            
            const structure = {
                tag: element.tagName,
                id: element.id,
                class: element.className.toString(),
                attributes: {},
                styles: {
                    position: element.style.position,
                    display: element.style.display,
                    zIndex: element.style.zIndex,
                    width: element.style.width,
                    height: element.style.height
                },
                shadowRoot: !!element.shadowRoot,
                children: []
            };
            
            // Get attributes
            for (const attr of element.attributes) {
                structure.attributes[attr.name] = attr.value;
            }
            
            // Get children (limit to prevent huge output)
            const children = element.shadowRoot ? 
                Array.from(element.shadowRoot.children) : 
                Array.from(element.children);
                
            structure.children = children.slice(0, 3).map(child => 
                buildElementStructure(child, depth + 1)
            );
            
            return structure;
        }
        
        function inspectShadowRoot(element) {
            if (!element.shadowRoot) return;
            
            log(`üåü Inspecting shadow root of ${element.tagName}`);
            
            // Find all elements in shadow
            const shadowElements = element.shadowRoot.querySelectorAll('*');
            log(`  Found ${shadowElements.length} elements in shadow DOM`);
            
            // Look for interesting elements
            const buttons = element.shadowRoot.querySelectorAll('button');
            const inputs = element.shadowRoot.querySelectorAll('input, textarea');
            const audios = element.shadowRoot.querySelectorAll('audio');
            const videos = element.shadowRoot.querySelectorAll('video');
            
            if (buttons.length) log(`  üîò ${buttons.length} buttons`);
            if (inputs.length) log(`  üìù ${inputs.length} inputs`);
            if (audios.length) log(`  üéµ ${audios.length} audio elements`);
            if (videos.length) log(`  üé• ${videos.length} video elements`);
            
            // Try to find transcript elements
            const transcriptSelectors = [
                '[class*="transcript"]',
                '[class*="message"]',
                '[class*="chat"]',
                '[class*="conversation"]',
                '[class*="text"]'
            ];
            
            transcriptSelectors.forEach(selector => {
                const elements = element.shadowRoot.querySelectorAll(selector);
                if (elements.length > 0) {
                    log(`  üìù Found ${elements.length} potential transcript elements with selector "${selector}"`);
                }
            });
        }
        
        function interceptTranscript() {
            log('üìù Setting up transcript interception...');
            
            const transcriptDiv = document.getElementById('transcript-display');
            const contentDiv = document.getElementById('transcript-content');
            transcriptDiv.style.display = 'block';
            
            // Monitor for mutations in the DOM
            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                // Check if it contains text that might be transcript
                                const text = node.textContent;
                                if (text && text.length > 0 && text.length < 1000) {
                                    // Check if it's likely speech (not code or UI text)
                                    if (!text.includes('{') && !text.includes('<') && 
                                        !text.includes('function') && !text.includes('const')) {
                                        
                                        const entry = document.createElement('div');
                                        entry.className = 'transcript-entry';
                                        entry.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                                        contentDiv.appendChild(entry);
                                        contentDiv.scrollTop = contentDiv.scrollHeight;
                                        
                                        log(`üìù Captured text: "${text.substring(0, 50)}..."`);
                                    }
                                }
                            }
                        });
                    }
                });
            });
            
            // Start observing
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                characterData: true
            });
            
            log('‚úÖ Transcript monitoring active');
            
            // Also intercept console messages
            const originalLog = console.log;
            console.log = function(...args) {
                originalLog.apply(console, args);
                
                // Check if it's transcript-like
                const message = args.join(' ');
                if (message.includes('transcript') || 
                    message.includes('speech') || 
                    message.includes('said') ||
                    message.includes('User:') ||
                    message.includes('AI:')) {
                    
                    const entry = document.createElement('div');
                    entry.className = 'transcript-entry system';
                    entry.textContent = `[Console] ${message}`;
                    contentDiv.appendChild(entry);
                }
            };
        }
        
        function forceInlineWidget() {
            log('üì¶ Attempting to force inline widget display...');
            
            // Find the widget
            const widget = document.querySelector('elevenlabs-convai');
            if (!widget) {
                log('‚ùå Widget not found. Load it first.');
                return;
            }
            
            // Override styles to make it inline
            const style = document.createElement('style');
            style.textContent = `
                elevenlabs-convai {
                    position: relative !important;
                    display: block !important;
                    width: 100% !important;
                    height: 600px !important;
                    max-width: 800px !important;
                    margin: 20px auto !important;
                    z-index: 1 !important;
                }
                
                elevenlabs-convai > * {
                    position: relative !important;
                }
                
                /* Try to override shadow DOM styles if possible */
                elevenlabs-convai::part(*) {
                    position: relative !important;
                }
            `;
            document.head.appendChild(style);
            
            // Move widget to our container
            const container = document.querySelector('.widget-demo');
            if (container && widget.parentElement !== container) {
                container.appendChild(widget);
                log('‚úÖ Widget moved to container');
            }
            
            // Try to access shadow root and modify styles
            if (widget.shadowRoot) {
                const shadowStyle = document.createElement('style');
                shadowStyle.textContent = `
                    :host {
                        position: relative !important;
                        display: block !important;
                        width: 100% !important;
                        height: 100% !important;
                    }
                    
                    * {
                        max-width: 100% !important;
                    }
                `;
                widget.shadowRoot.appendChild(shadowStyle);
                log('‚úÖ Shadow DOM styles injected');
            }
            
            log('üí° Widget display forced to inline. It may still render as overlay due to internal scripts.');
        }
        
        function captureCanvas() {
            log('üé® Searching for widget canvas animations...');
            
            const canvases = document.querySelectorAll('canvas');
            log(`üîç Found ${canvases.length} canvas elements`);
            
            const captureDiv = document.getElementById('canvas-capture');
            const containerDiv = document.getElementById('canvas-container');
            captureDiv.style.display = 'block';
            containerDiv.innerHTML = '';
            
            let widgetCanvases = [];
            
            canvases.forEach((canvas, index) => {
                const rect = canvas.getBoundingClientRect();
                const context = canvas.getContext('2d');
                
                log(`üìä Canvas ${index}: ${canvas.width}x${canvas.height} at (${rect.x}, ${rect.y})`);
                log(`  Classes: "${canvas.className}"`);
                log(`  Parent: ${canvas.parentElement?.tagName || 'unknown'}`);
                
                // Check if it's likely the widget canvas (small size, positioned)
                if (canvas.width <= 100 && canvas.height <= 100 && 
                    (canvas.className.includes('w-full') || canvas.className.includes('h-full') || 
                     rect.width > 0 && rect.height > 0)) {
                    
                    widgetCanvases.push(canvas);
                    log(`‚úÖ Identified as potential widget canvas`);
                    
                    // Create a larger clone
                    const clonedCanvas = document.createElement('canvas');
                    clonedCanvas.width = 200;
                    clonedCanvas.height = 200;
                    clonedCanvas.style.border = '2px solid #3498db';
                    clonedCanvas.style.borderRadius = '10px';
                    clonedCanvas.style.margin = '10px';
                    
                    const clonedCtx = clonedCanvas.getContext('2d');
                    
                    // Set up real-time copying
                    const copyAnimation = () => {
                        try {
                            // Clear the clone
                            clonedCtx.clearRect(0, 0, 200, 200);
                            
                            // Scale and copy the original canvas
                            clonedCtx.imageSmoothingEnabled = true;
                            clonedCtx.imageSmoothingQuality = 'high';
                            clonedCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 200, 200);
                            
                            // Continue animation
                            requestAnimationFrame(copyAnimation);
                        } catch (e) {
                            // Canvas might be tainted or not accessible
                            log(`‚ö†Ô∏è Canvas ${index} copy failed: ${e.message}`);
                        }
                    };
                    
                    // Start copying
                    copyAnimation();
                    
                    // Add to container
                    const wrapper = document.createElement('div');
                    wrapper.className = 'captured-canvas';
                    wrapper.appendChild(clonedCanvas);
                    
                    const label = document.createElement('div');
                    label.textContent = `Canvas ${index} (${canvas.width}x${canvas.height}) ‚Üí Enlarged`;
                    label.style.color = 'white';
                    label.style.fontSize = '14px';
                    label.style.marginTop = '10px';
                    wrapper.appendChild(label);
                    
                    containerDiv.appendChild(wrapper);
                }
            });
            
            if (widgetCanvases.length === 0) {
                log('‚ùå No widget canvases found. Make sure the widget is loaded and active.');
                
                // Try to find canvases in shadow DOMs
                const shadowRoots = [];
                document.querySelectorAll('*').forEach(el => {
                    if (el.shadowRoot) {
                        shadowRoots.push(el);
                    }
                });
                
                if (shadowRoots.length > 0) {
                    log(`üîç Searching in ${shadowRoots.length} shadow DOMs...`);
                    shadowRoots.forEach((el, i) => {
                        const shadowCanvases = el.shadowRoot.querySelectorAll('canvas');
                        if (shadowCanvases.length > 0) {
                            log(`‚úÖ Found ${shadowCanvases.length} canvas elements in shadow DOM ${i}`);
                            shadowCanvases.forEach(sc => {
                                log(`  Shadow Canvas: ${sc.width}x${sc.height}, classes: "${sc.className}"`);
                            });
                        }
                    });
                }
            } else {
                log(`‚úÖ Successfully captured ${widgetCanvases.length} widget canvas animations`);
            }
        }
        
        function createGenieBottle() {
            log('üßû Creating Genie Bottle with captured animation...');
            
            const canvases = document.querySelectorAll('canvas');
            let sourceCanvas = null;
            
            // Find the widget canvas
            canvases.forEach(canvas => {
                if (canvas.width <= 100 && canvas.height <= 100 && 
                    canvas.getBoundingClientRect().width > 0) {
                    sourceCanvas = canvas;
                }
            });
            
            if (!sourceCanvas) {
                // Try to find in shadow DOM
                document.querySelectorAll('*').forEach(el => {
                    if (el.shadowRoot) {
                        const shadowCanvases = el.shadowRoot.querySelectorAll('canvas');
                        shadowCanvases.forEach(sc => {
                            if (sc.width <= 100 && sc.height <= 100) {
                                sourceCanvas = sc;
                            }
                        });
                    }
                });
            }
            
            if (!sourceCanvas) {
                log('‚ùå No source canvas found. Try capturing canvas first.');
                return;
            }
            
            const captureDiv = document.getElementById('canvas-capture');
            const genieBottle = document.getElementById('genie-bottle');
            const genieCanvas = document.getElementById('genie-canvas');
            
            captureDiv.style.display = 'block';
            genieBottle.style.display = 'block';
            
            const genieCtx = genieCanvas.getContext('2d');
            
            log('‚úÖ Source canvas found, creating genie bottle animation...');
            
            // Enhanced animation with genie effects
            const animateGenie = () => {
                try {
                    // Clear canvas
                    genieCtx.clearRect(0, 0, 200, 200);
                    
                    // Create mystical background
                    const gradient = genieCtx.createRadialGradient(100, 100, 0, 100, 100, 100);
                    gradient.addColorStop(0, 'rgba(52, 152, 219, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(155, 89, 182, 0.2)');
                    gradient.addColorStop(1, 'rgba(41, 128, 185, 0.1)');
                    
                    genieCtx.fillStyle = gradient;
                    genieCtx.fillRect(0, 0, 200, 200);
                    
                    // Add swirling effect
                    const time = Date.now() * 0.003;
                    genieCtx.save();
                    genieCtx.translate(100, 100);
                    genieCtx.rotate(time * 0.5);
                    genieCtx.translate(-100, -100);
                    
                    // Draw the original widget animation (enlarged)
                    genieCtx.imageSmoothingEnabled = true;
                    genieCtx.imageSmoothingQuality = 'high';
                    
                    // Scale up the original canvas
                    const scale = 5; // Make it 5x larger
                    const offsetX = (200 - sourceCanvas.width * scale) / 2;
                    const offsetY = (200 - sourceCanvas.height * scale) / 2;
                    
                    genieCtx.drawImage(
                        sourceCanvas, 
                        0, 0, sourceCanvas.width, sourceCanvas.height,
                        offsetX, offsetY, sourceCanvas.width * scale, sourceCanvas.height * scale
                    );
                    
                    genieCtx.restore();
                    
                    // Add mystical particles
                    for (let i = 0; i < 5; i++) {
                        const angle = time + i * (Math.PI * 2 / 5);
                        const radius = 60 + Math.sin(time * 2 + i) * 20;
                        const x = 100 + Math.cos(angle) * radius;
                        const y = 100 + Math.sin(angle) * radius;
                        
                        genieCtx.beginPath();
                        genieCtx.arc(x, y, 3, 0, Math.PI * 2);
                        genieCtx.fillStyle = `hsla(${(time * 50 + i * 60) % 360}, 70%, 60%, 0.8)`;
                        genieCtx.fill();
                    }
                    
                    // Add glow effect
                    genieCtx.shadowColor = '#3498db';
                    genieCtx.shadowBlur = 20;
                    genieCtx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                    genieCtx.lineWidth = 2;
                    genieCtx.beginPath();
                    genieCtx.arc(100, 100, 90, 0, Math.PI * 2);
                    genieCtx.stroke();
                    genieCtx.shadowBlur = 0;
                    
                    requestAnimationFrame(animateGenie);
                } catch (e) {
                    log(`‚ö†Ô∏è Genie animation error: ${e.message}`);
                }
            };
            
            // Start the genie animation
            animateGenie();
            
            log('‚ú® Genie bottle created! The widget animation is now captured in a mystical bottle.');
        }
        
        // Function to monitor canvas changes
        function monitorCanvasActivity() {
            log('üëÅÔ∏è Monitoring canvas activity...');
            
            const canvases = document.querySelectorAll('canvas');
            
            canvases.forEach((canvas, index) => {
                if (canvas.width <= 100 && canvas.height <= 100) {
                    // Monitor for redraws
                    const originalGetContext = canvas.getContext;
                    let drawCount = 0;
                    
                    canvas.getContext = function(type) {
                        const ctx = originalGetContext.call(this, type);
                        
                        if (type === '2d') {
                            // Monitor drawing operations
                            const originalDrawImage = ctx.drawImage;
                            const originalFillRect = ctx.fillRect;
                            const originalBeginPath = ctx.beginPath;
                            
                            ctx.drawImage = function() {
                                drawCount++;
                                if (drawCount % 30 === 0) { // Log every 30 draws to avoid spam
                                    log(`üé® Canvas ${index} activity: ${drawCount} draw operations`);
                                }
                                return originalDrawImage.apply(this, arguments);
                            };
                            
                            ctx.fillRect = function() {
                                drawCount++;
                                return originalFillRect.apply(this, arguments);
                            };
                        }
                        
                        return ctx;
                    };
                }
            });
        }
        
        // Widget Control Functions
        let currentOverlay = null;
        let originalOverlayParent = null;
        let overlayObserver = null;
        
        function controlWidget() {
            log('üéÆ Initializing widget controller...');
            
            const controllerDiv = document.getElementById('widget-controller');
            controllerDiv.style.display = 'block';
            
            // Start monitoring for overlay appearances
            startOverlayMonitoring();
            
            // Try to find existing overlay
            findAndControlOverlay();
        }
        
        function startOverlayMonitoring() {
            log('üëÅÔ∏è Starting overlay monitoring...');
            
            // Monitor for new DOM additions
            overlayObserver = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                // Check if it's an overlay
                                if (node.classList?.contains('overlay') || 
                                    node.querySelector?.('.overlay') ||
                                    (node.className && node.className.includes('overlay'))) {
                                    
                                    log('‚úÖ Detected new overlay element!');
                                    setTimeout(() => findAndControlOverlay(), 100);
                                }
                                
                                // Also check for the specific classes you mentioned
                                if (node.querySelector?.('[data-shown="true"]') ||
                                    node.classList?.contains('transition-opacity') ||
                                    node.querySelector?.('.rounded-sheet')) {
                                    
                                    log('‚úÖ Detected widget dialog element!');
                                    setTimeout(() => findAndControlOverlay(), 100);
                                }
                            }
                        });
                    }
                });
            });
            
            overlayObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
        }
        
        function findAndControlOverlay() {
            log('üîç Searching for widget overlays...');
            
            // Look for overlay elements with specific classes
            const overlaySelectors = [
                '.overlay',
                '[data-shown="true"]',
                '.rounded-sheet',
                '.bg-base.shadow-lg',
                '[class*="overlay"]',
                '.transition-opacity.duration-200'
            ];
            
            let foundOverlay = null;
            
            for (const selector of overlaySelectors) {
                const elements = document.querySelectorAll(selector);
                for (const element of elements) {
                    const rect = element.getBoundingClientRect();
                    const styles = window.getComputedStyle(element);
                    
                    // Check if it looks like a dialog overlay
                    if ((styles.position === 'fixed' || styles.position === 'absolute') &&
                        rect.width > 100 && rect.height > 100) {
                        
                        log(`‚úÖ Found overlay: ${element.className}`);
                        foundOverlay = element;
                        break;
                    }
                }
                if (foundOverlay) break;
            }
            
            // Also search in shadow DOMs
            if (!foundOverlay) {
                document.querySelectorAll('*').forEach(el => {
                    if (el.shadowRoot) {
                        const shadowOverlays = el.shadowRoot.querySelectorAll('.overlay, [data-shown="true"]');
                        if (shadowOverlays.length > 0) {
                            foundOverlay = shadowOverlays[0];
                            log('‚úÖ Found overlay in shadow DOM');
                        }
                    }
                });
            }
            
            if (foundOverlay) {
                hijackOverlayElement(foundOverlay);
            } else {
                log('‚ùå No overlay found. Try clicking the widget first.');
            }
        }
        
        function hijackOverlayElement(overlay) {
            log('üéØ Hijacking overlay element...');
            
            currentOverlay = overlay;
            originalOverlayParent = overlay.parentElement;
            
            // Clone the overlay to preserve the original
            const clonedOverlay = overlay.cloneNode(true);
            
            // Store original styles
            const originalStyles = {
                position: overlay.style.position,
                display: overlay.style.display,
                width: overlay.style.width,
                height: overlay.style.height,
                bottom: overlay.style.bottom,
                right: overlay.style.right,
                top: overlay.style.top,
                left: overlay.style.left,
                zIndex: overlay.style.zIndex,
                transform: overlay.style.transform
            };
            
            // Log original styles
            log('üìã Original overlay styles:');
            Object.entries(originalStyles).forEach(([key, value]) => {
                if (value) log(`  ${key}: ${value}`);
            });
            
            // Keep the original widget in place but make it transparent
            overlay.style.opacity = '0.3';
            overlay.style.pointerEvents = 'none';
            log('üëª Made original widget semi-transparent');
            
            // Add the clone to our controller
            const container = document.getElementById('controlled-overlay-container');
            container.appendChild(clonedOverlay);
            
            // Apply control styles to the clone
            clonedOverlay.classList.add('controlled-overlay');
            clonedOverlay.style.position = 'relative';
            clonedOverlay.style.display = 'block';
            clonedOverlay.style.width = '100%';
            clonedOverlay.style.height = 'auto';
            clonedOverlay.style.bottom = 'auto';
            clonedOverlay.style.right = 'auto';
            clonedOverlay.style.top = 'auto';
            clonedOverlay.style.left = 'auto';
            clonedOverlay.style.margin = '20px auto';
            clonedOverlay.style.opacity = '1';
            clonedOverlay.style.pointerEvents = 'auto';
            clonedOverlay.style.zIndex = 'auto';
            clonedOverlay.style.transform = 'none';
            
            // Store reference to the clone
            currentOverlay = clonedOverlay;
            
            log('‚úÖ Overlay cloned and added to controller!');
            log('üëª Original widget remains in place (semi-transparent)');
            log('üéÆ Clone is now under our control in the controller section');
            
            // Try to reactivate event listeners on the clone
            setTimeout(() => {
                // Find all interactive elements and try to make them work
                const buttons = clonedOverlay.querySelectorAll('button, [role="button"]');
                log(`üîò Found ${buttons.length} buttons in cloned overlay`);
                
                buttons.forEach((btn, index) => {
                    btn.addEventListener('click', (e) => {
                        log(`üîò Button ${index} clicked in clone!`);
                    });
                });
                
                // Extract any canvases from the overlay
                extractCanvasFromOverlay();
            }, 100);
        }
        
        function simulateClick() {
            log('üëÜ Simulating widget click (single click only)...');
            
            // Find the widget element
            const widget = document.querySelector('elevenlabs-convai');
            if (!widget) {
                log('‚ùå Widget not found. Load it first.');
                return;
            }
            
            // Try to find the main clickable element within the widget
            const clickTarget = widget.shadowRoot?.querySelector('button') || 
                               widget.shadowRoot?.querySelector('[role="button"]') || 
                               widget.shadowRoot?.querySelector('div[cursor="pointer"]') || 
                               widget.shadowRoot?.querySelector('.cursor-pointer') ||
                               widget;
            
            if (clickTarget) {
                try {
                    // Create and dispatch a single click event
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    
                    log(`üëÜ Clicking widget once...`);
                    clickTarget.dispatchEvent(clickEvent);
                    
                    log(`‚úÖ Single click completed`);
                } catch (e) {
                    log(`‚ö†Ô∏è Click simulation failed: ${e.message}`);
                }
            } else {
                log('‚ùå No clickable target found');
            }
            
            // Check for overlay after a delay
            setTimeout(() => {
                log('üîç Looking for overlay after click...');
                findAndControlOverlay();
            }, 1000);
        }
        
        function hijackOverlay() {
            log('üéØ Manual overlay hijack...');
            findAndControlOverlay();
        }
        
        function startCall() {
            log('üìû Starting call...');
            
            // Look for "Start a call" or "New call" buttons
            const callButtons = document.querySelectorAll('button[aria-label*="call"], button:contains("New call"), button:contains("Start")');
            
            callButtons.forEach(button => {
                if (button.textContent.includes('call') || button.textContent.includes('Start')) {
                    log('üìû Found call button, clicking...');
                    button.click();
                }
            });
            
            // Also try in shadow DOMs
            document.querySelectorAll('*').forEach(el => {
                if (el.shadowRoot) {
                    const shadowButtons = el.shadowRoot.querySelectorAll('button[aria-label*="call"], button');
                    shadowButtons.forEach(btn => {
                        if (btn.textContent?.includes('call') || btn.getAttribute('aria-label')?.includes('call')) {
                            log('üìû Found shadow call button, clicking...');
                            btn.click();
                        }
                    });
                }
            });
        }
        
        function endCall() {
            log('üìµ Ending call...');
            
            // Look for end call buttons
            const endButtons = document.querySelectorAll('button[aria-label*="end"], button:contains("End"), button:contains("Stop")');
            
            endButtons.forEach(button => {
                log('üìµ Found end button, clicking...');
                button.click();
            });
        }
        
        function toggleOverlay() {
            log('üëÅÔ∏è Toggling overlay visibility...');
            
            if (currentOverlay) {
                const isVisible = currentOverlay.style.display !== 'none';
                currentOverlay.style.display = isVisible ? 'none' : 'block';
                log(`üëÅÔ∏è Overlay ${isVisible ? 'hidden' : 'shown'}`);
            } else {
                log('‚ùå No overlay under control. Try hijacking first.');
            }
        }
        
        function extractCanvasFromOverlay() {
            log('üé® Extracting canvas from controlled overlay...');
            
            if (!currentOverlay) {
                log('‚ùå No overlay under control.');
                return;
            }
            
            const canvases = currentOverlay.querySelectorAll('canvas');
            log(`üîç Found ${canvases.length} canvas elements in overlay`);
            
            canvases.forEach((canvas, index) => {
                log(`üìä Canvas ${index}: ${canvas.width}x${canvas.height}`);
                
                // Create enlarged version
                if (canvas.width > 0 && canvas.height > 0) {
                    const enlargedCanvas = document.createElement('canvas');
                    enlargedCanvas.width = 300;
                    enlargedCanvas.height = 300;
                    enlargedCanvas.style.border = '3px solid #e74c3c';
                    enlargedCanvas.style.borderRadius = '15px';
                    enlargedCanvas.style.margin = '10px';
                    
                    const enlargedCtx = enlargedCanvas.getContext('2d');
                    
                    // Copy and scale
                    const copyAnimation = () => {
                        try {
                            enlargedCtx.clearRect(0, 0, 300, 300);
                            enlargedCtx.imageSmoothingEnabled = true;
                            enlargedCtx.imageSmoothingQuality = 'high';
                            enlargedCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 300, 300);
                            requestAnimationFrame(copyAnimation);
                        } catch (e) {
                            // Handle cross-origin issues
                        }
                    };
                    
                    copyAnimation();
                    
                    // Add to overlay
                    const wrapper = document.createElement('div');
                    wrapper.style.textAlign = 'center';
                    wrapper.style.margin = '20px 0';
                    wrapper.appendChild(enlargedCanvas);
                    
                    const label = document.createElement('div');
                    label.textContent = `Enlarged Widget Animation (${canvas.width}x${canvas.height} ‚Üí 300x300)`;
                    label.style.color = 'white';
                    label.style.marginTop = '10px';
                    wrapper.appendChild(label);
                    
                    currentOverlay.appendChild(wrapper);
                    
                    log(`‚úÖ Added enlarged canvas ${index} to overlay`);
                }
            });
        }
        
        // Custom command test functions
        function testCustomCommand() {
            if (!widgetHijacker || !widgetHijacker.conversation) {
                log('‚ùå Widget not hijacked yet. Load widget and wait for hijacking first.');
                return;
            }
            
            const command = prompt('Enter custom command to send:', 'Tell me a joke');
            if (command) {
                widgetHijacker.sendCustomCommand(command);
            }
        }
        
        function testUpdateContext() {
            if (!widgetHijacker || !widgetHijacker.conversation) {
                log('‚ùå Widget not hijacked yet. Load widget and wait for hijacking first.');
                return;
            }
            
            const contextInfo = {
                topic: 'technology',
                mood: 'friendly',
                timestamp: new Date().toISOString()
            };
            
            log('üìù Sending context update:', contextInfo);
            widgetHijacker.updateContext(contextInfo);
        }
        
        // Initialize
        log('üöÄ Widget Inspector initialized');
        log('üí° Click "Load Real Widget" to begin inspection');
        log('üîß If widget fails to load, check console for detailed errors');
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'l':
                        e.preventDefault();
                        loadWidget();
                        break;
                    case 'i':
                        e.preventDefault();
                        inspectWidget();
                        break;
                    case 'd':
                        e.preventDefault();
                        debugLoadingIssues();
                        break;
                    case 'c':
                        e.preventDefault();
                        captureOverlay();
                        break;
                    case 't':
                        e.preventDefault();
                        interceptTranscript();
                        break;
                }
            }
        });
        
        log('‚å®Ô∏è Keyboard shortcuts: Ctrl+L (Load), Ctrl+I (Inspect), Ctrl+D (Debug), Ctrl+C (Capture), Ctrl+T (Transcript)');
    </script>
</body>
</html>